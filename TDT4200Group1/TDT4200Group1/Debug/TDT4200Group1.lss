
TDT4200Group1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000017c  00800100  00000fc2  00001056  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fc2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000017  0080027c  0080027c  000011d2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011d2  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002d0  00000000  00000000  00001202  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002a23  00000000  00000000  000014d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000edb  00000000  00000000  00003ef5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000dcc  00000000  00000000  00004dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000744  00000000  00000000  00005b9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000080d  00000000  00000000  000062e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000183d  00000000  00000000  00006aed  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000270  00000000  00000000  0000832a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__ctors_end>
   4:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
   8:	0c 94 68 03 	jmp	0x6d0	; 0x6d0 <__vector_2>
   c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  10:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  14:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  18:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  1c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  20:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  24:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  28:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  2c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  30:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  34:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  38:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  3c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  40:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  44:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  48:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  4c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  50:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  54:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  58:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  5c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  60:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  64:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  68:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>
  6c:	0c 94 43 01 	jmp	0x286	; 0x286 <__bad_interrupt>

00000070 <__trampolines_end>:
  70:	00 00       	nop
  72:	00 00       	nop
  74:	00 00       	nop
  76:	00 5f       	subi	r16, 0xF0	; 240
  78:	00 00       	nop
  7a:	00 07       	cpc	r16, r16
  7c:	00 07       	cpc	r16, r16
  7e:	00 14       	cp	r0, r0
  80:	7f 14       	cp	r7, r15
  82:	7f 14       	cp	r7, r15
  84:	24 2a       	or	r2, r20
  86:	7f 2a       	or	r7, r31
  88:	12 23       	and	r17, r18
  8a:	13 08       	sbc	r1, r3
  8c:	64 62       	ori	r22, 0x24	; 36
  8e:	36 49       	sbci	r19, 0x96	; 150
  90:	55 22       	and	r5, r21
  92:	50 00       	.word	0x0050	; ????
  94:	05 03       	mulsu	r16, r21
  96:	00 00       	nop
  98:	00 1c       	adc	r0, r0
  9a:	22 41       	sbci	r18, 0x12	; 18
  9c:	00 00       	nop
  9e:	41 22       	and	r4, r17
  a0:	1c 00       	.word	0x001c	; ????
  a2:	08 2a       	or	r0, r24
  a4:	1c 2a       	or	r1, r28
  a6:	08 08       	sbc	r0, r8
  a8:	08 3e       	cpi	r16, 0xE8	; 232
  aa:	08 08       	sbc	r0, r8
  ac:	00 50       	subi	r16, 0x00	; 0
  ae:	30 00       	.word	0x0030	; ????
  b0:	00 08       	sbc	r0, r0
  b2:	08 08       	sbc	r0, r8
  b4:	08 08       	sbc	r0, r8
  b6:	00 60       	ori	r16, 0x00	; 0
  b8:	60 00       	.word	0x0060	; ????
  ba:	00 20       	and	r0, r0
  bc:	10 08       	sbc	r1, r0
  be:	04 02       	muls	r16, r20
  c0:	3e 51       	subi	r19, 0x1E	; 30
  c2:	49 45       	sbci	r20, 0x59	; 89
  c4:	3e 00       	.word	0x003e	; ????
  c6:	42 7f       	andi	r20, 0xF2	; 242
  c8:	40 00       	.word	0x0040	; ????
  ca:	42 61       	ori	r20, 0x12	; 18
  cc:	51 49       	sbci	r21, 0x91	; 145
  ce:	46 21       	and	r20, r6
  d0:	41 45       	sbci	r20, 0x51	; 81
  d2:	4b 31       	cpi	r20, 0x1B	; 27
  d4:	18 14       	cp	r1, r8
  d6:	12 7f       	andi	r17, 0xF2	; 242
  d8:	10 27       	eor	r17, r16
  da:	45 45       	sbci	r20, 0x55	; 85
  dc:	45 39       	cpi	r20, 0x95	; 149
  de:	3c 4a       	sbci	r19, 0xAC	; 172
  e0:	49 49       	sbci	r20, 0x99	; 153
  e2:	30 01       	movw	r6, r0
  e4:	71 09       	sbc	r23, r1
  e6:	05 03       	mulsu	r16, r21
  e8:	36 49       	sbci	r19, 0x96	; 150
  ea:	49 49       	sbci	r20, 0x99	; 153
  ec:	36 06       	cpc	r3, r22
  ee:	49 49       	sbci	r20, 0x99	; 153
  f0:	29 1e       	adc	r2, r25
  f2:	00 36       	cpi	r16, 0x60	; 96
  f4:	36 00       	.word	0x0036	; ????
  f6:	00 00       	nop
  f8:	56 36       	cpi	r21, 0x66	; 102
  fa:	00 00       	nop
  fc:	00 08       	sbc	r0, r0
  fe:	14 22       	and	r1, r20
 100:	41 14       	cp	r4, r1
 102:	14 14       	cp	r1, r4
 104:	14 14       	cp	r1, r4
 106:	41 22       	and	r4, r17
 108:	14 08       	sbc	r1, r4
 10a:	00 02       	muls	r16, r16
 10c:	01 51       	subi	r16, 0x11	; 17
 10e:	09 06       	cpc	r0, r25
 110:	32 49       	sbci	r19, 0x92	; 146
 112:	79 41       	sbci	r23, 0x19	; 25
 114:	3e 7e       	andi	r19, 0xEE	; 238
 116:	11 11       	cpse	r17, r1
 118:	11 7e       	andi	r17, 0xE1	; 225
 11a:	7f 49       	sbci	r23, 0x9F	; 159
 11c:	49 49       	sbci	r20, 0x99	; 153
 11e:	36 3e       	cpi	r19, 0xE6	; 230
 120:	41 41       	sbci	r20, 0x11	; 17
 122:	41 22       	and	r4, r17
 124:	7f 41       	sbci	r23, 0x1F	; 31
 126:	41 22       	and	r4, r17
 128:	1c 7f       	andi	r17, 0xFC	; 252
 12a:	49 49       	sbci	r20, 0x99	; 153
 12c:	49 41       	sbci	r20, 0x19	; 25
 12e:	7f 09       	sbc	r23, r15
 130:	09 01       	movw	r0, r18
 132:	01 3e       	cpi	r16, 0xE1	; 225
 134:	41 41       	sbci	r20, 0x11	; 17
 136:	51 32       	cpi	r21, 0x21	; 33
 138:	7f 08       	sbc	r7, r15
 13a:	08 08       	sbc	r0, r8
 13c:	7f 00       	.word	0x007f	; ????
 13e:	41 7f       	andi	r20, 0xF1	; 241
 140:	41 00       	.word	0x0041	; ????
 142:	20 40       	sbci	r18, 0x00	; 0
 144:	41 3f       	cpi	r20, 0xF1	; 241
 146:	01 7f       	andi	r16, 0xF1	; 241
 148:	08 14       	cp	r0, r8
 14a:	22 41       	sbci	r18, 0x12	; 18
 14c:	7f 40       	sbci	r23, 0x0F	; 15
 14e:	40 40       	sbci	r20, 0x00	; 0
 150:	40 7f       	andi	r20, 0xF0	; 240
 152:	02 04       	cpc	r0, r2
 154:	02 7f       	andi	r16, 0xF2	; 242
 156:	7f 04       	cpc	r7, r15
 158:	08 10       	cpse	r0, r8
 15a:	7f 3e       	cpi	r23, 0xEF	; 239
 15c:	41 41       	sbci	r20, 0x11	; 17
 15e:	41 3e       	cpi	r20, 0xE1	; 225
 160:	7f 09       	sbc	r23, r15
 162:	09 09       	sbc	r16, r9
 164:	06 3e       	cpi	r16, 0xE6	; 230
 166:	41 51       	subi	r20, 0x11	; 17
 168:	21 5e       	subi	r18, 0xE1	; 225
 16a:	7f 09       	sbc	r23, r15
 16c:	19 29       	or	r17, r9
 16e:	46 46       	sbci	r20, 0x66	; 102
 170:	49 49       	sbci	r20, 0x99	; 153
 172:	49 31       	cpi	r20, 0x19	; 25
 174:	01 01       	movw	r0, r2
 176:	7f 01       	movw	r14, r30
 178:	01 3f       	cpi	r16, 0xF1	; 241
 17a:	40 40       	sbci	r20, 0x00	; 0
 17c:	40 3f       	cpi	r20, 0xF0	; 240
 17e:	1f 20       	and	r1, r15
 180:	40 20       	and	r4, r0
 182:	1f 7f       	andi	r17, 0xFF	; 255
 184:	20 18       	sub	r2, r0
 186:	20 7f       	andi	r18, 0xF0	; 240
 188:	63 14       	cp	r6, r3
 18a:	08 14       	cp	r0, r8
 18c:	63 03       	mulsu	r22, r19
 18e:	04 78       	andi	r16, 0x84	; 132
 190:	04 03       	mulsu	r16, r20
 192:	61 51       	subi	r22, 0x11	; 17
 194:	49 45       	sbci	r20, 0x59	; 89
 196:	43 00       	.word	0x0043	; ????
 198:	00 7f       	andi	r16, 0xF0	; 240
 19a:	41 41       	sbci	r20, 0x11	; 17
 19c:	02 04       	cpc	r0, r2
 19e:	08 10       	cpse	r0, r8
 1a0:	20 41       	sbci	r18, 0x10	; 16
 1a2:	41 7f       	andi	r20, 0xF1	; 241
 1a4:	00 00       	nop
 1a6:	04 02       	muls	r16, r20
 1a8:	01 02       	muls	r16, r17
 1aa:	04 40       	sbci	r16, 0x04	; 4
 1ac:	40 40       	sbci	r20, 0x00	; 0
 1ae:	40 40       	sbci	r20, 0x00	; 0
 1b0:	00 01       	movw	r0, r0
 1b2:	02 04       	cpc	r0, r2
 1b4:	00 20       	and	r0, r0
 1b6:	54 54       	subi	r21, 0x44	; 68
 1b8:	54 78       	andi	r21, 0x84	; 132
 1ba:	7f 48       	sbci	r23, 0x8F	; 143
 1bc:	44 44       	sbci	r20, 0x44	; 68
 1be:	38 38       	cpi	r19, 0x88	; 136
 1c0:	44 44       	sbci	r20, 0x44	; 68
 1c2:	44 20       	and	r4, r4
 1c4:	38 44       	sbci	r19, 0x48	; 72
 1c6:	44 48       	sbci	r20, 0x84	; 132
 1c8:	7f 38       	cpi	r23, 0x8F	; 143
 1ca:	54 54       	subi	r21, 0x44	; 68
 1cc:	54 18       	sub	r5, r4
 1ce:	08 7e       	andi	r16, 0xE8	; 232
 1d0:	09 01       	movw	r0, r18
 1d2:	02 08       	sbc	r0, r2
 1d4:	14 54       	subi	r17, 0x44	; 68
 1d6:	54 3c       	cpi	r21, 0xC4	; 196
 1d8:	7f 08       	sbc	r7, r15
 1da:	04 04       	cpc	r0, r4
 1dc:	78 00       	.word	0x0078	; ????
 1de:	44 7d       	andi	r20, 0xD4	; 212
 1e0:	40 00       	.word	0x0040	; ????
 1e2:	20 40       	sbci	r18, 0x00	; 0
 1e4:	44 3d       	cpi	r20, 0xD4	; 212
 1e6:	00 00       	nop
 1e8:	7f 10       	cpse	r7, r15
 1ea:	28 44       	sbci	r18, 0x48	; 72
 1ec:	00 41       	sbci	r16, 0x10	; 16
 1ee:	7f 40       	sbci	r23, 0x0F	; 15
 1f0:	00 7c       	andi	r16, 0xC0	; 192
 1f2:	04 18       	sub	r0, r4
 1f4:	04 78       	andi	r16, 0x84	; 132
 1f6:	7c 08       	sbc	r7, r12
 1f8:	04 04       	cpc	r0, r4
 1fa:	78 38       	cpi	r23, 0x88	; 136
 1fc:	44 44       	sbci	r20, 0x44	; 68
 1fe:	44 38       	cpi	r20, 0x84	; 132
 200:	7c 14       	cp	r7, r12
 202:	14 14       	cp	r1, r4
 204:	08 08       	sbc	r0, r8
 206:	14 14       	cp	r1, r4
 208:	18 7c       	andi	r17, 0xC8	; 200
 20a:	7c 08       	sbc	r7, r12
 20c:	04 04       	cpc	r0, r4
 20e:	08 48       	sbci	r16, 0x88	; 136
 210:	54 54       	subi	r21, 0x44	; 68
 212:	54 20       	and	r5, r4
 214:	04 3f       	cpi	r16, 0xF4	; 244
 216:	44 40       	sbci	r20, 0x04	; 4
 218:	20 3c       	cpi	r18, 0xC0	; 192
 21a:	40 40       	sbci	r20, 0x00	; 0
 21c:	20 7c       	andi	r18, 0xC0	; 192
 21e:	1c 20       	and	r1, r12
 220:	40 20       	and	r4, r0
 222:	1c 3c       	cpi	r17, 0xCC	; 204
 224:	40 30       	cpi	r20, 0x00	; 0
 226:	40 3c       	cpi	r20, 0xC0	; 192
 228:	44 28       	or	r4, r4
 22a:	10 28       	or	r1, r0
 22c:	44 0c       	add	r4, r4
 22e:	50 50       	subi	r21, 0x00	; 0
 230:	50 3c       	cpi	r21, 0xC0	; 192
 232:	44 64       	ori	r20, 0x44	; 68
 234:	54 4c       	sbci	r21, 0xC4	; 196
 236:	44 00       	.word	0x0044	; ????
 238:	08 36       	cpi	r16, 0x68	; 104
 23a:	41 00       	.word	0x0041	; ????
 23c:	00 00       	nop
 23e:	7f 00       	.word	0x007f	; ????
 240:	00 00       	nop
 242:	41 36       	cpi	r20, 0x61	; 97
 244:	08 00       	.word	0x0008	; ????
 246:	02 01       	movw	r0, r4
 248:	03 02       	muls	r16, r19
 24a:	01 00       	.word	0x0001	; ????

0000024c <__ctors_end>:
 24c:	11 24       	eor	r1, r1
 24e:	1f be       	out	0x3f, r1	; 63
 250:	cf ef       	ldi	r28, 0xFF	; 255
 252:	d4 e0       	ldi	r29, 0x04	; 4
 254:	de bf       	out	0x3e, r29	; 62
 256:	cd bf       	out	0x3d, r28	; 61

00000258 <__do_copy_data>:
 258:	12 e0       	ldi	r17, 0x02	; 2
 25a:	a0 e0       	ldi	r26, 0x00	; 0
 25c:	b1 e0       	ldi	r27, 0x01	; 1
 25e:	e2 ec       	ldi	r30, 0xC2	; 194
 260:	ff e0       	ldi	r31, 0x0F	; 15
 262:	02 c0       	rjmp	.+4      	; 0x268 <__do_copy_data+0x10>
 264:	05 90       	lpm	r0, Z+
 266:	0d 92       	st	X+, r0
 268:	ac 37       	cpi	r26, 0x7C	; 124
 26a:	b1 07       	cpc	r27, r17
 26c:	d9 f7       	brne	.-10     	; 0x264 <__do_copy_data+0xc>

0000026e <__do_clear_bss>:
 26e:	22 e0       	ldi	r18, 0x02	; 2
 270:	ac e7       	ldi	r26, 0x7C	; 124
 272:	b2 e0       	ldi	r27, 0x02	; 2
 274:	01 c0       	rjmp	.+2      	; 0x278 <.do_clear_bss_start>

00000276 <.do_clear_bss_loop>:
 276:	1d 92       	st	X+, r1

00000278 <.do_clear_bss_start>:
 278:	a3 39       	cpi	r26, 0x93	; 147
 27a:	b2 07       	cpc	r27, r18
 27c:	e1 f7       	brne	.-8      	; 0x276 <.do_clear_bss_loop>
 27e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <main>
 282:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <_exit>

00000286 <__bad_interrupt>:
 286:	0c 94 bd 04 	jmp	0x97a	; 0x97a <__vector_default>

0000028a <calibrateJoystick>:
#include "adc.h"

int null_X, null_Y;

void calibrateJoystick(){
	null_X = null_Y =0;
 28a:	10 92 88 02 	sts	0x0288, r1
 28e:	10 92 87 02 	sts	0x0287, r1
 292:	10 92 82 02 	sts	0x0282, r1
 296:	10 92 81 02 	sts	0x0281, r1
	null_Y = ADC_read(ADC_Y_AXIS);
}

uint8_t ADC_read( int channelNumber) {
	volatile uint8_t* ptr = (uint8_t*) 0x1400;
	*ptr = channelNumber;
 29a:	85 e0       	ldi	r24, 0x05	; 5
 29c:	80 93 00 14 	sts	0x1400, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2a0:	82 e5       	ldi	r24, 0x52	; 82
 2a2:	8a 95       	dec	r24
 2a4:	f1 f7       	brne	.-4      	; 0x2a2 <calibrateJoystick+0x18>
	_delay_us(50);
	return *ptr;
 2a6:	e0 e0       	ldi	r30, 0x00	; 0
 2a8:	f4 e1       	ldi	r31, 0x14	; 20
 2aa:	80 81       	ld	r24, Z

int null_X, null_Y;

void calibrateJoystick(){
	null_X = null_Y =0;
	null_X = ADC_read(ADC_X_AXIS);
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	90 93 82 02 	sts	0x0282, r25
 2b2:	80 93 81 02 	sts	0x0281, r24
	null_Y = ADC_read(ADC_Y_AXIS);
}

uint8_t ADC_read( int channelNumber) {
	volatile uint8_t* ptr = (uint8_t*) 0x1400;
	*ptr = channelNumber;
 2b6:	84 e0       	ldi	r24, 0x04	; 4
 2b8:	80 83       	st	Z, r24
 2ba:	82 e5       	ldi	r24, 0x52	; 82
 2bc:	8a 95       	dec	r24
 2be:	f1 f7       	brne	.-4      	; 0x2bc <calibrateJoystick+0x32>
	_delay_us(50);
	return *ptr;
 2c0:	80 91 00 14 	lds	r24, 0x1400
int null_X, null_Y;

void calibrateJoystick(){
	null_X = null_Y =0;
	null_X = ADC_read(ADC_X_AXIS);
	null_Y = ADC_read(ADC_Y_AXIS);
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	90 93 88 02 	sts	0x0288, r25
 2ca:	80 93 87 02 	sts	0x0287, r24
 2ce:	08 95       	ret

000002d0 <buttons_init>:
 
#include "buttons.h"


void buttons_init() {
	PORTB = 0x01<<2;
 2d0:	84 e0       	ldi	r24, 0x04	; 4
 2d2:	88 bb       	out	0x18, r24	; 24
	DDRB = 0x00;
 2d4:	17 ba       	out	0x17, r1	; 23
 2d6:	08 95       	ret

000002d8 <can_setMode>:

	// The status register is not changed before the first request to send
}

void can_setMode(char mode) {
	 mcp_bitModify(MCP_CANCTRL, CAN_MASK_MODE, mode);
 2d8:	48 2f       	mov	r20, r24
 2da:	60 ee       	ldi	r22, 0xE0	; 224
 2dc:	8f e0       	ldi	r24, 0x0F	; 15
 2de:	0e 94 8e 04 	call	0x91c	; 0x91c <mcp_bitModify>
 2e2:	08 95       	ret

000002e4 <can_init>:
#include "can.h"
#include "../MCP/mcp.h"
#include "../SPI/spi.h"
#include "avr/interrupt.h"
#include "can_buffer.h"
void can_init() {
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	00 d0       	rcall	.+0      	; 0x2ea <can_init+0x6>
 2ea:	cd b7       	in	r28, 0x3d	; 61
 2ec:	de b7       	in	r29, 0x3e	; 62

	spi_init();
 2ee:	0e 94 d1 05 	call	0xba2	; 0xba2 <spi_init>
	mcp_init();
 2f2:	0e 94 b8 04 	call	0x970	; 0x970 <mcp_init>
		
	//self-test
	char value;
	mcp_read(MCP_CANSTAT, &value, 1);
 2f6:	41 e0       	ldi	r20, 0x01	; 1
 2f8:	50 e0       	ldi	r21, 0x00	; 0
 2fa:	be 01       	movw	r22, r28
 2fc:	6f 5f       	subi	r22, 0xFF	; 255
 2fe:	7f 4f       	sbci	r23, 0xFF	; 255
 300:	8e e0       	ldi	r24, 0x0E	; 14
 302:	0e 94 0d 04 	call	0x81a	; 0x81a <mcp_read>
	if((value & MODE_MASK) != MODE_CONFIG){
 306:	89 81       	ldd	r24, Y+1	; 0x01
 308:	80 7e       	andi	r24, 0xE0	; 224
 30a:	80 38       	cpi	r24, 0x80	; 128
 30c:	29 f0       	breq	.+10     	; 0x318 <can_init+0x34>
		printf_char("MCP2515 is NOT in configuration mode after reset!\n");
 30e:	8b e0       	ldi	r24, 0x0B	; 11
 310:	91 e0       	ldi	r25, 0x01	; 1
 312:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
 316:	04 c0       	rjmp	.+8      	; 0x320 <can_init+0x3c>
	} else {
		printf_char("can_init complete\n");
 318:	8e e3       	ldi	r24, 0x3E	; 62
 31a:	91 e0       	ldi	r25, 0x01	; 1
 31c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	}
	
	//loop back mode
	can_setMode(CAN_MODE_LOOPBACK);
 320:	80 e4       	ldi	r24, 0x40	; 64
 322:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <can_setMode>
	
	//check Loop-Back-Mode
	char check;
	mcp_read(MCP_CANCTRL, &check, 1);
 326:	41 e0       	ldi	r20, 0x01	; 1
 328:	50 e0       	ldi	r21, 0x00	; 0
 32a:	be 01       	movw	r22, r28
 32c:	6e 5f       	subi	r22, 0xFE	; 254
 32e:	7f 4f       	sbci	r23, 0xFF	; 255
 330:	8f e0       	ldi	r24, 0x0F	; 15
 332:	0e 94 0d 04 	call	0x81a	; 0x81a <mcp_read>
	printf_char("check: ");
 336:	81 e5       	ldi	r24, 0x51	; 81
 338:	91 e0       	ldi	r25, 0x01	; 1
 33a:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	printf_int(check);
 33e:	8a 81       	ldd	r24, Y+2	; 0x02
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	printf_char("\n");
 346:	81 ec       	ldi	r24, 0xC1	; 193
 348:	91 e0       	ldi	r25, 0x01	; 1
 34a:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	//
	char status = mcp_readStatus();
 34e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <mcp_readStatus>
	printf_int(status);
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	printf_char("\n");
 358:	81 ec       	ldi	r24, 0xC1	; 193
 35a:	91 e0       	ldi	r25, 0x01	; 1
 35c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>

	// The status register is not changed before the first request to send
}
 360:	0f 90       	pop	r0
 362:	0f 90       	pop	r0
 364:	df 91       	pop	r29
 366:	cf 91       	pop	r28
 368:	08 95       	ret

0000036a <can_create_massage>:

void can_setMode(char mode) {
	 mcp_bitModify(MCP_CANCTRL, CAN_MASK_MODE, mode);
}

struct can_message can_create_massage(int id, char length, char data[]) {
 36a:	bf 92       	push	r11
 36c:	cf 92       	push	r12
 36e:	df 92       	push	r13
 370:	ef 92       	push	r14
 372:	ff 92       	push	r15
 374:	0f 93       	push	r16
 376:	1f 93       	push	r17
 378:	cf 93       	push	r28
 37a:	df 93       	push	r29
 37c:	cd b7       	in	r28, 0x3d	; 61
 37e:	de b7       	in	r29, 0x3e	; 62
 380:	2b 97       	sbiw	r28, 0x0b	; 11
 382:	0f b6       	in	r0, 0x3f	; 63
 384:	f8 94       	cli
 386:	de bf       	out	0x3e, r29	; 62
 388:	0f be       	out	0x3f, r0	; 63
 38a:	cd bf       	out	0x3d, r28	; 61
 38c:	8c 01       	movw	r16, r24
 38e:	7b 01       	movw	r14, r22
 390:	d4 2e       	mov	r13, r20
 392:	c2 2e       	mov	r12, r18
 394:	b3 2e       	mov	r11, r19
	struct can_message msg;
	msg.id = id;
	msg.length = length;
	if (length > MAX_MESSAGE_LENGTH){
 396:	88 e0       	ldi	r24, 0x08	; 8
 398:	84 17       	cp	r24, r20
 39a:	00 f5       	brcc	.+64     	; 0x3dc <can_create_massage+0x72>
		printf_char("Unable to make a message of the desired length\n");
 39c:	89 e5       	ldi	r24, 0x59	; 89
 39e:	91 e0       	ldi	r25, 0x01	; 1
 3a0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
		printf_int(length);
 3a4:	8d 2d       	mov	r24, r13
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
		printf_char(" Is larger than ");
 3ac:	89 e8       	ldi	r24, 0x89	; 137
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
		printf_int((int)(MAX_MESSAGE_LENGTH));
 3b4:	88 e0       	ldi	r24, 0x08	; 8
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
		printf_char("\n");
 3bc:	81 ec       	ldi	r24, 0xC1	; 193
 3be:	91 e0       	ldi	r25, 0x01	; 1
 3c0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
		msg.length = MAX_MESSAGE_LENGTH;
	}
	for(int i = 0; i < msg.length; i++)	{
 3c4:	68 e0       	ldi	r22, 0x08	; 8
 3c6:	70 e0       	ldi	r23, 0x00	; 0
		printf_char("Unable to make a message of the desired length\n");
		printf_int(length);
		printf_char(" Is larger than ");
		printf_int((int)(MAX_MESSAGE_LENGTH));
		printf_char("\n");
		msg.length = MAX_MESSAGE_LENGTH;
 3c8:	68 94       	set
 3ca:	dd 24       	eor	r13, r13
 3cc:	d3 f8       	bld	r13, 3
 3ce:	ec 2d       	mov	r30, r12
 3d0:	fb 2d       	mov	r31, r11
 3d2:	de 01       	movw	r26, r28
 3d4:	14 96       	adiw	r26, 0x04	; 4
 3d6:	20 e0       	ldi	r18, 0x00	; 0
 3d8:	30 e0       	ldi	r19, 0x00	; 0
 3da:	06 c0       	rjmp	.+12     	; 0x3e8 <can_create_massage+0x7e>
	}
	for(int i = 0; i < msg.length; i++)	{
 3dc:	64 2f       	mov	r22, r20
 3de:	70 e0       	ldi	r23, 0x00	; 0
 3e0:	16 16       	cp	r1, r22
 3e2:	17 06       	cpc	r1, r23
 3e4:	a4 f3       	brlt	.-24     	; 0x3ce <can_create_massage+0x64>
 3e6:	07 c0       	rjmp	.+14     	; 0x3f6 <can_create_massage+0x8c>
		msg.data[i] = data[i];
 3e8:	91 91       	ld	r25, Z+
 3ea:	9d 93       	st	X+, r25
		printf_char(" Is larger than ");
		printf_int((int)(MAX_MESSAGE_LENGTH));
		printf_char("\n");
		msg.length = MAX_MESSAGE_LENGTH;
	}
	for(int i = 0; i < msg.length; i++)	{
 3ec:	2f 5f       	subi	r18, 0xFF	; 255
 3ee:	3f 4f       	sbci	r19, 0xFF	; 255
 3f0:	26 17       	cp	r18, r22
 3f2:	37 07       	cpc	r19, r23
 3f4:	cc f3       	brlt	.-14     	; 0x3e8 <can_create_massage+0x7e>
		msg.data[i] = data[i];
	}
	return msg;
 3f6:	fa 82       	std	Y+2, r15	; 0x02
 3f8:	e9 82       	std	Y+1, r14	; 0x01
 3fa:	db 82       	std	Y+3, r13	; 0x03
 3fc:	8b e0       	ldi	r24, 0x0B	; 11
 3fe:	fe 01       	movw	r30, r28
 400:	31 96       	adiw	r30, 0x01	; 1
 402:	d8 01       	movw	r26, r16
 404:	01 90       	ld	r0, Z+
 406:	0d 92       	st	X+, r0
 408:	8a 95       	dec	r24
 40a:	e1 f7       	brne	.-8      	; 0x404 <can_create_massage+0x9a>
}
 40c:	c8 01       	movw	r24, r16
 40e:	2b 96       	adiw	r28, 0x0b	; 11
 410:	0f b6       	in	r0, 0x3f	; 63
 412:	f8 94       	cli
 414:	de bf       	out	0x3e, r29	; 62
 416:	0f be       	out	0x3f, r0	; 63
 418:	cd bf       	out	0x3d, r28	; 61
 41a:	df 91       	pop	r29
 41c:	cf 91       	pop	r28
 41e:	1f 91       	pop	r17
 420:	0f 91       	pop	r16
 422:	ff 90       	pop	r15
 424:	ef 90       	pop	r14
 426:	df 90       	pop	r13
 428:	cf 90       	pop	r12
 42a:	bf 90       	pop	r11
 42c:	08 95       	ret

0000042e <can_message_to_buffer>:

void can_message_to_buffer(struct can_message* msg, enum TRANSMIT_BUFFER txb) {
 42e:	af 92       	push	r10
 430:	bf 92       	push	r11
 432:	cf 92       	push	r12
 434:	df 92       	push	r13
 436:	ef 92       	push	r14
 438:	ff 92       	push	r15
 43a:	0f 93       	push	r16
 43c:	1f 93       	push	r17
 43e:	cf 93       	push	r28
 440:	df 93       	push	r29
 442:	00 d0       	rcall	.+0      	; 0x444 <can_message_to_buffer+0x16>
 444:	cd b7       	in	r28, 0x3d	; 61
 446:	de b7       	in	r29, 0x3e	; 62
 448:	8c 01       	movw	r16, r24
 44a:	d6 2e       	mov	r13, r22
	char idAdress, lengthAdress, dataAdress;
	
	if(txb == TXB0) {
 44c:	66 23       	and	r22, r22
 44e:	71 f0       	breq	.+28     	; 0x46c <can_message_to_buffer+0x3e>
		idAdress = MCP_TXB0SIDH;
		lengthAdress = MCP_TXB0DLC;
		dataAdress = MCP_TXB0D0;
	} else if(txb == TXB1) {
 450:	81 e0       	ldi	r24, 0x01	; 1
 452:	68 17       	cp	r22, r24
 454:	c1 f0       	breq	.+48     	; 0x486 <can_message_to_buffer+0x58>
		idAdress = MCP_TXB1SIDH;
		lengthAdress = MCP_TXB1DLC;
		dataAdress = MCP_TXB1D0;
	} else if(txb == TXB2) {
 456:	e2 e0       	ldi	r30, 0x02	; 2
 458:	6e 17       	cp	r22, r30
 45a:	11 f1       	breq	.+68     	; 0x4a0 <can_message_to_buffer+0x72>
		idAdress = MCP_TXB2SIDH;
		lengthAdress = MCP_TXB2DLC;
		dataAdress = MCP_TXB2D0;
	} else if(txb == TXBALL) {
 45c:	f3 e0       	ldi	r31, 0x03	; 3
 45e:	6f 13       	cpse	r22, r31
 460:	2b c0       	rjmp	.+86     	; 0x4b8 <can_message_to_buffer+0x8a>
		printf_char("you can only fill one buffer at a time!\n");
 462:	8a e9       	ldi	r24, 0x9A	; 154
 464:	91 e0       	ldi	r25, 0x01	; 1
 466:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
 46a:	26 c0       	rjmp	.+76     	; 0x4b8 <can_message_to_buffer+0x8a>
	char idAdress, lengthAdress, dataAdress;
	
	if(txb == TXB0) {
		idAdress = MCP_TXB0SIDH;
		lengthAdress = MCP_TXB0DLC;
		dataAdress = MCP_TXB0D0;
 46c:	0f 2e       	mov	r0, r31
 46e:	f6 e3       	ldi	r31, 0x36	; 54
 470:	cf 2e       	mov	r12, r31
 472:	f0 2d       	mov	r31, r0
void can_message_to_buffer(struct can_message* msg, enum TRANSMIT_BUFFER txb) {
	char idAdress, lengthAdress, dataAdress;
	
	if(txb == TXB0) {
		idAdress = MCP_TXB0SIDH;
		lengthAdress = MCP_TXB0DLC;
 474:	0f 2e       	mov	r0, r31
 476:	f5 e3       	ldi	r31, 0x35	; 53
 478:	bf 2e       	mov	r11, r31
 47a:	f0 2d       	mov	r31, r0

void can_message_to_buffer(struct can_message* msg, enum TRANSMIT_BUFFER txb) {
	char idAdress, lengthAdress, dataAdress;
	
	if(txb == TXB0) {
		idAdress = MCP_TXB0SIDH;
 47c:	0f 2e       	mov	r0, r31
 47e:	f1 e3       	ldi	r31, 0x31	; 49
 480:	af 2e       	mov	r10, r31
 482:	f0 2d       	mov	r31, r0
 484:	19 c0       	rjmp	.+50     	; 0x4b8 <can_message_to_buffer+0x8a>
		lengthAdress = MCP_TXB0DLC;
		dataAdress = MCP_TXB0D0;
	} else if(txb == TXB1) {
		idAdress = MCP_TXB1SIDH;
		lengthAdress = MCP_TXB1DLC;
		dataAdress = MCP_TXB1D0;
 486:	0f 2e       	mov	r0, r31
 488:	f6 e4       	ldi	r31, 0x46	; 70
 48a:	cf 2e       	mov	r12, r31
 48c:	f0 2d       	mov	r31, r0
		idAdress = MCP_TXB0SIDH;
		lengthAdress = MCP_TXB0DLC;
		dataAdress = MCP_TXB0D0;
	} else if(txb == TXB1) {
		idAdress = MCP_TXB1SIDH;
		lengthAdress = MCP_TXB1DLC;
 48e:	0f 2e       	mov	r0, r31
 490:	f5 e4       	ldi	r31, 0x45	; 69
 492:	bf 2e       	mov	r11, r31
 494:	f0 2d       	mov	r31, r0
	if(txb == TXB0) {
		idAdress = MCP_TXB0SIDH;
		lengthAdress = MCP_TXB0DLC;
		dataAdress = MCP_TXB0D0;
	} else if(txb == TXB1) {
		idAdress = MCP_TXB1SIDH;
 496:	0f 2e       	mov	r0, r31
 498:	f1 e4       	ldi	r31, 0x41	; 65
 49a:	af 2e       	mov	r10, r31
 49c:	f0 2d       	mov	r31, r0
 49e:	0c c0       	rjmp	.+24     	; 0x4b8 <can_message_to_buffer+0x8a>
		lengthAdress = MCP_TXB1DLC;
		dataAdress = MCP_TXB1D0;
	} else if(txb == TXB2) {
		idAdress = MCP_TXB2SIDH;
		lengthAdress = MCP_TXB2DLC;
		dataAdress = MCP_TXB2D0;
 4a0:	0f 2e       	mov	r0, r31
 4a2:	f6 e5       	ldi	r31, 0x56	; 86
 4a4:	cf 2e       	mov	r12, r31
 4a6:	f0 2d       	mov	r31, r0
		idAdress = MCP_TXB1SIDH;
		lengthAdress = MCP_TXB1DLC;
		dataAdress = MCP_TXB1D0;
	} else if(txb == TXB2) {
		idAdress = MCP_TXB2SIDH;
		lengthAdress = MCP_TXB2DLC;
 4a8:	0f 2e       	mov	r0, r31
 4aa:	f5 e5       	ldi	r31, 0x55	; 85
 4ac:	bf 2e       	mov	r11, r31
 4ae:	f0 2d       	mov	r31, r0
	} else if(txb == TXB1) {
		idAdress = MCP_TXB1SIDH;
		lengthAdress = MCP_TXB1DLC;
		dataAdress = MCP_TXB1D0;
	} else if(txb == TXB2) {
		idAdress = MCP_TXB2SIDH;
 4b0:	0f 2e       	mov	r0, r31
 4b2:	f1 e5       	ldi	r31, 0x51	; 81
 4b4:	af 2e       	mov	r10, r31
 4b6:	f0 2d       	mov	r31, r0
		printf_char("you can only fill one buffer at a time!\n");
	}
	
	// SET THE ID in the MCP
	char ID[2];
	ID[0] = (msg->id >> 3) & 0xFF; // High bits of the ID
 4b8:	f8 01       	movw	r30, r16
 4ba:	21 91       	ld	r18, Z+
 4bc:	31 91       	ld	r19, Z+
 4be:	7f 01       	movw	r14, r30
 4c0:	a9 01       	movw	r20, r18
 4c2:	56 95       	lsr	r21
 4c4:	47 95       	ror	r20
 4c6:	56 95       	lsr	r21
 4c8:	47 95       	ror	r20
 4ca:	56 95       	lsr	r21
 4cc:	47 95       	ror	r20
 4ce:	49 83       	std	Y+1, r20	; 0x01
	ID[1] = (msg->id & 0x07) << 5; // Low bits of the ID
 4d0:	22 95       	swap	r18
 4d2:	22 0f       	add	r18, r18
 4d4:	20 7e       	andi	r18, 0xE0	; 224
 4d6:	2a 83       	std	Y+2, r18	; 0x02
	mcp_write(idAdress, ID, 2);
 4d8:	42 e0       	ldi	r20, 0x02	; 2
 4da:	50 e0       	ldi	r21, 0x00	; 0
 4dc:	be 01       	movw	r22, r28
 4de:	6f 5f       	subi	r22, 0xFF	; 255
 4e0:	7f 4f       	sbci	r23, 0xFF	; 255
 4e2:	8a 2d       	mov	r24, r10
 4e4:	0e 94 33 04 	call	0x866	; 0x866 <mcp_write>
	// Set the length of the CAN-message 
	mcp_write(lengthAdress, &msg->length, 1);
 4e8:	41 e0       	ldi	r20, 0x01	; 1
 4ea:	50 e0       	ldi	r21, 0x00	; 0
 4ec:	b7 01       	movw	r22, r14
 4ee:	8b 2d       	mov	r24, r11
 4f0:	0e 94 33 04 	call	0x866	; 0x866 <mcp_write>
	// Fill in the Data of the CAN-message 
	mcp_write(dataAdress, &msg->data[0], msg->length);
 4f4:	f8 01       	movw	r30, r16
 4f6:	42 81       	ldd	r20, Z+2	; 0x02
 4f8:	50 e0       	ldi	r21, 0x00	; 0
 4fa:	b8 01       	movw	r22, r16
 4fc:	6d 5f       	subi	r22, 0xFD	; 253
 4fe:	7f 4f       	sbci	r23, 0xFF	; 255
 500:	8c 2d       	mov	r24, r12
 502:	0e 94 33 04 	call	0x866	; 0x866 <mcp_write>
	
	mcp_requestToSend(txb);
 506:	8d 2d       	mov	r24, r13
 508:	0e 94 59 04 	call	0x8b2	; 0x8b2 <mcp_requestToSend>
}
 50c:	0f 90       	pop	r0
 50e:	0f 90       	pop	r0
 510:	df 91       	pop	r29
 512:	cf 91       	pop	r28
 514:	1f 91       	pop	r17
 516:	0f 91       	pop	r16
 518:	ff 90       	pop	r15
 51a:	ef 90       	pop	r14
 51c:	df 90       	pop	r13
 51e:	cf 90       	pop	r12
 520:	bf 90       	pop	r11
 522:	af 90       	pop	r10
 524:	08 95       	ret

00000526 <can_send_message>:

void can_send_message(struct can_message* msg) {
 526:	cf 93       	push	r28
 528:	df 93       	push	r29
 52a:	ec 01       	movw	r28, r24
	//find free transieve_buffer
	char status = mcp_readStatus();
 52c:	0e 94 78 04 	call	0x8f0	; 0x8f0 <mcp_readStatus>
	
	
	can_message_to_buffer(msg, TXB0);
 530:	60 e0       	ldi	r22, 0x00	; 0
 532:	ce 01       	movw	r24, r28
 534:	0e 94 17 02 	call	0x42e	; 0x42e <can_message_to_buffer>
}
 538:	df 91       	pop	r29
 53a:	cf 91       	pop	r28
 53c:	08 95       	ret

0000053e <parseId>:

boolean can_transmit_complete() {
	return true;
}

int parseId (char* input){
 53e:	fc 01       	movw	r30, r24
	int output =  (input[1] >> 5) & 0x07;
 540:	81 81       	ldd	r24, Z+1	; 0x01
 542:	82 95       	swap	r24
 544:	86 95       	lsr	r24
 546:	87 70       	andi	r24, 0x07	; 7
	output += (((int)input[0] ) << 3);
 548:	20 81       	ld	r18, Z
 54a:	90 e0       	ldi	r25, 0x00	; 0
	return output;
}
 54c:	38 e0       	ldi	r19, 0x08	; 8
 54e:	23 9f       	mul	r18, r19
 550:	80 0d       	add	r24, r0
 552:	91 1d       	adc	r25, r1
 554:	11 24       	eor	r1, r1
 556:	08 95       	ret

00000558 <can_recieve_message>:

struct can_message can_recieve_message(enum RECIEVE_BUFFER rcb) { //TODO: check id
 558:	cf 92       	push	r12
 55a:	df 92       	push	r13
 55c:	ef 92       	push	r14
 55e:	ff 92       	push	r15
 560:	0f 93       	push	r16
 562:	1f 93       	push	r17
 564:	cf 93       	push	r28
 566:	df 93       	push	r29
 568:	cd b7       	in	r28, 0x3d	; 61
 56a:	de b7       	in	r29, 0x3e	; 62
 56c:	2b 97       	sbiw	r28, 0x0b	; 11
 56e:	0f b6       	in	r0, 0x3f	; 63
 570:	f8 94       	cli
 572:	de bf       	out	0x3e, r29	; 62
 574:	0f be       	out	0x3f, r0	; 63
 576:	cd bf       	out	0x3d, r28	; 61
 578:	8c 01       	movw	r16, r24
 57a:	f6 2e       	mov	r15, r22
	char idAdress, lengthAdress, dataAdress;
	
	

	mcp_bitModify(MCP_CANINTF, 0x01, 0x00);
 57c:	40 e0       	ldi	r20, 0x00	; 0
 57e:	61 e0       	ldi	r22, 0x01	; 1
 580:	8c e2       	ldi	r24, 0x2C	; 44
 582:	0e 94 8e 04 	call	0x91c	; 0x91c <mcp_bitModify>

	
	if(rcb == RXB0) {
 586:	81 e0       	ldi	r24, 0x01	; 1
 588:	f8 16       	cp	r15, r24
 58a:	21 f0       	breq	.+8      	; 0x594 <can_recieve_message+0x3c>
		idAdress = MCP_RXB0SIDH; 
		lengthAdress = MCP_RXB0DLC;
		dataAdress = MCP_RXB0D0;
	} else if(rcb == RXB1) {
 58c:	82 e0       	ldi	r24, 0x02	; 2
 58e:	f8 12       	cpse	r15, r24
 590:	1a c0       	rjmp	.+52     	; 0x5c6 <can_recieve_message+0x6e>
 592:	0d c0       	rjmp	.+26     	; 0x5ae <can_recieve_message+0x56>

	
	if(rcb == RXB0) {
		idAdress = MCP_RXB0SIDH; 
		lengthAdress = MCP_RXB0DLC;
		dataAdress = MCP_RXB0D0;
 594:	0f 2e       	mov	r0, r31
 596:	f6 e6       	ldi	r31, 0x66	; 102
 598:	df 2e       	mov	r13, r31
 59a:	f0 2d       	mov	r31, r0
	mcp_bitModify(MCP_CANINTF, 0x01, 0x00);

	
	if(rcb == RXB0) {
		idAdress = MCP_RXB0SIDH; 
		lengthAdress = MCP_RXB0DLC;
 59c:	0f 2e       	mov	r0, r31
 59e:	f5 e6       	ldi	r31, 0x65	; 101
 5a0:	cf 2e       	mov	r12, r31
 5a2:	f0 2d       	mov	r31, r0

	mcp_bitModify(MCP_CANINTF, 0x01, 0x00);

	
	if(rcb == RXB0) {
		idAdress = MCP_RXB0SIDH; 
 5a4:	0f 2e       	mov	r0, r31
 5a6:	f1 e6       	ldi	r31, 0x61	; 97
 5a8:	ef 2e       	mov	r14, r31
 5aa:	f0 2d       	mov	r31, r0
 5ac:	0c c0       	rjmp	.+24     	; 0x5c6 <can_recieve_message+0x6e>
		lengthAdress = MCP_RXB0DLC;
		dataAdress = MCP_RXB0D0;
	} else if(rcb == RXB1) {
		idAdress = MCP_RXB1SIDH;
		lengthAdress = MCP_RXB1DLC;
		dataAdress = MCP_RXB1D0;
 5ae:	0f 2e       	mov	r0, r31
 5b0:	f6 e7       	ldi	r31, 0x76	; 118
 5b2:	df 2e       	mov	r13, r31
 5b4:	f0 2d       	mov	r31, r0
		idAdress = MCP_RXB0SIDH; 
		lengthAdress = MCP_RXB0DLC;
		dataAdress = MCP_RXB0D0;
	} else if(rcb == RXB1) {
		idAdress = MCP_RXB1SIDH;
		lengthAdress = MCP_RXB1DLC;
 5b6:	0f 2e       	mov	r0, r31
 5b8:	f5 e7       	ldi	r31, 0x75	; 117
 5ba:	cf 2e       	mov	r12, r31
 5bc:	f0 2d       	mov	r31, r0
	if(rcb == RXB0) {
		idAdress = MCP_RXB0SIDH; 
		lengthAdress = MCP_RXB0DLC;
		dataAdress = MCP_RXB0D0;
	} else if(rcb == RXB1) {
		idAdress = MCP_RXB1SIDH;
 5be:	0f 2e       	mov	r0, r31
 5c0:	f1 e7       	ldi	r31, 0x71	; 113
 5c2:	ef 2e       	mov	r14, r31
 5c4:	f0 2d       	mov	r31, r0
		lengthAdress = MCP_RXB1DLC;
		dataAdress = MCP_RXB1D0;
	}

	char tmp[2];
	mcp_read(idAdress, &tmp[0], 2);
 5c6:	42 e0       	ldi	r20, 0x02	; 2
 5c8:	50 e0       	ldi	r21, 0x00	; 0
 5ca:	be 01       	movw	r22, r28
 5cc:	6f 5f       	subi	r22, 0xFF	; 255
 5ce:	7f 4f       	sbci	r23, 0xFF	; 255
 5d0:	8e 2d       	mov	r24, r14
 5d2:	0e 94 0d 04 	call	0x81a	; 0x81a <mcp_read>
	int id = parseId(tmp);
 5d6:	ce 01       	movw	r24, r28
 5d8:	01 96       	adiw	r24, 0x01	; 1
 5da:	0e 94 9f 02 	call	0x53e	; 0x53e <parseId>
 5de:	7c 01       	movw	r14, r24
	char length;
	mcp_read(lengthAdress, &length, 1);
 5e0:	41 e0       	ldi	r20, 0x01	; 1
 5e2:	50 e0       	ldi	r21, 0x00	; 0
 5e4:	be 01       	movw	r22, r28
 5e6:	6d 5f       	subi	r22, 0xFD	; 253
 5e8:	7f 4f       	sbci	r23, 0xFF	; 255
 5ea:	8c 2d       	mov	r24, r12
 5ec:	0e 94 0d 04 	call	0x81a	; 0x81a <mcp_read>
	char data[MAX_MESSAGE_LENGTH];
	mcp_read(dataAdress, &data[0], length);
 5f0:	4b 81       	ldd	r20, Y+3	; 0x03
 5f2:	50 e0       	ldi	r21, 0x00	; 0
 5f4:	be 01       	movw	r22, r28
 5f6:	6c 5f       	subi	r22, 0xFC	; 252
 5f8:	7f 4f       	sbci	r23, 0xFF	; 255
 5fa:	8d 2d       	mov	r24, r13
 5fc:	0e 94 0d 04 	call	0x81a	; 0x81a <mcp_read>
	
	struct can_message recv_msg = can_create_massage(id, length, data);
 600:	9e 01       	movw	r18, r28
 602:	2c 5f       	subi	r18, 0xFC	; 252
 604:	3f 4f       	sbci	r19, 0xFF	; 255
 606:	4b 81       	ldd	r20, Y+3	; 0x03
 608:	b7 01       	movw	r22, r14
 60a:	c8 01       	movw	r24, r16
 60c:	0e 94 b5 01 	call	0x36a	; 0x36a <can_create_massage>
	

	return recv_msg;
}
 610:	c8 01       	movw	r24, r16
 612:	2b 96       	adiw	r28, 0x0b	; 11
 614:	0f b6       	in	r0, 0x3f	; 63
 616:	f8 94       	cli
 618:	de bf       	out	0x3e, r29	; 62
 61a:	0f be       	out	0x3f, r0	; 63
 61c:	cd bf       	out	0x3d, r28	; 61
 61e:	df 91       	pop	r29
 620:	cf 91       	pop	r28
 622:	1f 91       	pop	r17
 624:	0f 91       	pop	r16
 626:	ff 90       	pop	r15
 628:	ef 90       	pop	r14
 62a:	df 90       	pop	r13
 62c:	cf 90       	pop	r12
 62e:	08 95       	ret

00000630 <can_print_message>:

void can_print_message(struct can_message* msg) {
 630:	ef 92       	push	r14
 632:	ff 92       	push	r15
 634:	0f 93       	push	r16
 636:	1f 93       	push	r17
 638:	cf 93       	push	r28
 63a:	df 93       	push	r29
 63c:	7c 01       	movw	r14, r24
	printf_char("Can_Message: \n	ID: ");
 63e:	83 ec       	ldi	r24, 0xC3	; 195
 640:	91 e0       	ldi	r25, 0x01	; 1
 642:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	printf_int(msg->id);
 646:	f7 01       	movw	r30, r14
 648:	80 81       	ld	r24, Z
 64a:	91 81       	ldd	r25, Z+1	; 0x01
 64c:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	printf_char("\n	length: ");
 650:	87 ed       	ldi	r24, 0xD7	; 215
 652:	91 e0       	ldi	r25, 0x01	; 1
 654:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	printf_int(msg->length);
 658:	f7 01       	movw	r30, r14
 65a:	82 81       	ldd	r24, Z+2	; 0x02
 65c:	90 e0       	ldi	r25, 0x00	; 0
 65e:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	printf_char("\n	data: ");
 662:	82 ee       	ldi	r24, 0xE2	; 226
 664:	91 e0       	ldi	r25, 0x01	; 1
 666:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	for(int i = 0; i < msg->length; i++) {
 66a:	f7 01       	movw	r30, r14
 66c:	82 81       	ldd	r24, Z+2	; 0x02
 66e:	88 23       	and	r24, r24
 670:	b1 f0       	breq	.+44     	; 0x69e <can_print_message+0x6e>
 672:	87 01       	movw	r16, r14
 674:	0d 5f       	subi	r16, 0xFD	; 253
 676:	1f 4f       	sbci	r17, 0xFF	; 255
 678:	c0 e0       	ldi	r28, 0x00	; 0
 67a:	d0 e0       	ldi	r29, 0x00	; 0
		printf_int(msg->data[i]);
 67c:	f8 01       	movw	r30, r16
 67e:	81 91       	ld	r24, Z+
 680:	8f 01       	movw	r16, r30
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
		printf_char(",");
 688:	8b ee       	ldi	r24, 0xEB	; 235
 68a:	91 e0       	ldi	r25, 0x01	; 1
 68c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	printf_char("Can_Message: \n	ID: ");
	printf_int(msg->id);
	printf_char("\n	length: ");
	printf_int(msg->length);
	printf_char("\n	data: ");
	for(int i = 0; i < msg->length; i++) {
 690:	21 96       	adiw	r28, 0x01	; 1
 692:	f7 01       	movw	r30, r14
 694:	22 81       	ldd	r18, Z+2	; 0x02
 696:	30 e0       	ldi	r19, 0x00	; 0
 698:	c2 17       	cp	r28, r18
 69a:	d3 07       	cpc	r29, r19
 69c:	7c f3       	brlt	.-34     	; 0x67c <can_print_message+0x4c>
		printf_int(msg->data[i]);
		printf_char(",");
	}
	printf_char("\n");
 69e:	81 ec       	ldi	r24, 0xC1	; 193
 6a0:	91 e0       	ldi	r25, 0x01	; 1
 6a2:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
}
 6a6:	df 91       	pop	r29
 6a8:	cf 91       	pop	r28
 6aa:	1f 91       	pop	r17
 6ac:	0f 91       	pop	r16
 6ae:	ff 90       	pop	r15
 6b0:	ef 90       	pop	r14
 6b2:	08 95       	ret

000006b4 <can_findFullReceiveBuffer>:
}


enum RECIEVE_BUFFER can_findFullReceiveBuffer(char status){
	
	if( (enum RECIEVE_BUFFER)status & RXB0){
 6b4:	80 fd       	sbrc	r24, 0
 6b6:	08 c0       	rjmp	.+16     	; 0x6c8 <can_findFullReceiveBuffer+0x14>
		return RXB0;
	}
	else if((enum RECIEVE_BUFFER)status & RXB1){
 6b8:	81 fd       	sbrc	r24, 1
 6ba:	08 c0       	rjmp	.+16     	; 0x6cc <can_findFullReceiveBuffer+0x18>
		return RXB1;
	}
	else{
		printf_char("Error, no receive-buffer is full\n");
 6bc:	8d ee       	ldi	r24, 0xED	; 237
 6be:	91 e0       	ldi	r25, 0x01	; 1
 6c0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
		return 0;
 6c4:	80 e0       	ldi	r24, 0x00	; 0
 6c6:	08 95       	ret


enum RECIEVE_BUFFER can_findFullReceiveBuffer(char status){
	
	if( (enum RECIEVE_BUFFER)status & RXB0){
		return RXB0;
 6c8:	81 e0       	ldi	r24, 0x01	; 1
 6ca:	08 95       	ret
	}
	else if((enum RECIEVE_BUFFER)status & RXB1){
		return RXB1;
 6cc:	82 e0       	ldi	r24, 0x02	; 2
	}
	else{
		printf_char("Error, no receive-buffer is full\n");
		return 0;
	}
};
 6ce:	08 95       	ret

000006d0 <__vector_2>:
		copy_onto->data[i] = copy_from->data[i];
	}
	
}

ISR(INT1_vect){
 6d0:	1f 92       	push	r1
 6d2:	0f 92       	push	r0
 6d4:	0f b6       	in	r0, 0x3f	; 63
 6d6:	0f 92       	push	r0
 6d8:	11 24       	eor	r1, r1
 6da:	2f 93       	push	r18
 6dc:	3f 93       	push	r19
 6de:	4f 93       	push	r20
 6e0:	5f 93       	push	r21
 6e2:	6f 93       	push	r22
 6e4:	7f 93       	push	r23
 6e6:	8f 93       	push	r24
 6e8:	9f 93       	push	r25
 6ea:	af 93       	push	r26
 6ec:	bf 93       	push	r27
 6ee:	ef 93       	push	r30
 6f0:	ff 93       	push	r31
 6f2:	cf 93       	push	r28
 6f4:	df 93       	push	r29
 6f6:	cd b7       	in	r28, 0x3d	; 61
 6f8:	de b7       	in	r29, 0x3e	; 62
 6fa:	2b 97       	sbiw	r28, 0x0b	; 11
 6fc:	de bf       	out	0x3e, r29	; 62
 6fe:	cd bf       	out	0x3d, r28	; 61
	
	// Interrupt when CAN receives a message
	printf_char( "Received message by interrupt\n");
 700:	8f e0       	ldi	r24, 0x0F	; 15
 702:	92 e0       	ldi	r25, 0x02	; 2
 704:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	int temp = GIFR;
 708:	8a b7       	in	r24, 0x3a	; 58
	printf_int(temp);
 70a:	90 e0       	ldi	r25, 0x00	; 0
 70c:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	
	char status = mcp_readStatus();
 710:	0e 94 78 04 	call	0x8f0	; 0x8f0 <mcp_readStatus>
	enum RECIEVE_BUFFER buffer = can_findFullReceiveBuffer(status);
 714:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <can_findFullReceiveBuffer>
	struct can_message recv = can_recieve_message(buffer);
 718:	68 2f       	mov	r22, r24
 71a:	ce 01       	movw	r24, r28
 71c:	01 96       	adiw	r24, 0x01	; 1
 71e:	0e 94 ac 02 	call	0x558	; 0x558 <can_recieve_message>
	printf( "Adding message to buffer..\n");
	//can_buffer_addMessageToBuffer(&recv);
	#endif //INCLUDE_CAN_BUFFER

	#ifndef INCLUDE_CAN_BUFFER
	printf_char("Printing\n");
 722:	8e e2       	ldi	r24, 0x2E	; 46
 724:	92 e0       	ldi	r25, 0x02	; 2
 726:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	can_print_message(&recv);
 72a:	ce 01       	movw	r24, r28
 72c:	01 96       	adiw	r24, 0x01	; 1
 72e:	0e 94 18 03 	call	0x630	; 0x630 <can_print_message>
	#endif //INCLUDE_CAN_BUFFER
	printf_char("Inerrupt done\n");
 732:	88 e3       	ldi	r24, 0x38	; 56
 734:	92 e0       	ldi	r25, 0x02	; 2
 736:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	sei();
 73a:	78 94       	sei
 73c:	2b 96       	adiw	r28, 0x0b	; 11
 73e:	0f b6       	in	r0, 0x3f	; 63
 740:	f8 94       	cli
 742:	de bf       	out	0x3e, r29	; 62
 744:	0f be       	out	0x3f, r0	; 63
 746:	cd bf       	out	0x3d, r28	; 61
 748:	df 91       	pop	r29
 74a:	cf 91       	pop	r28
 74c:	ff 91       	pop	r31
 74e:	ef 91       	pop	r30
 750:	bf 91       	pop	r27
 752:	af 91       	pop	r26
 754:	9f 91       	pop	r25
 756:	8f 91       	pop	r24
 758:	7f 91       	pop	r23
 75a:	6f 91       	pop	r22
 75c:	5f 91       	pop	r21
 75e:	4f 91       	pop	r20
 760:	3f 91       	pop	r19
 762:	2f 91       	pop	r18
 764:	0f 90       	pop	r0
 766:	0f be       	out	0x3f, r0	; 63
 768:	0f 90       	pop	r0
 76a:	1f 90       	pop	r1
 76c:	18 95       	reti

0000076e <XMEM_Init>:

#include "main.h"
#include "MCP/mcp.h"
#include "./CAN/can_buffer.h"
void XMEM_Init() {
	MCUCR |= (1<<SRE);
 76e:	85 b7       	in	r24, 0x35	; 53
 770:	80 68       	ori	r24, 0x80	; 128
 772:	85 bf       	out	0x35, r24	; 53
	SFIOR |= (1<<XMM2);
 774:	80 b7       	in	r24, 0x30	; 48
 776:	80 62       	ori	r24, 0x20	; 32
 778:	80 bf       	out	0x30, r24	; 48
 77a:	08 95       	ret

0000077c <init>:
}

void init() {
	usart_init( MYUBRR );
 77c:	8f e1       	ldi	r24, 0x1F	; 31
 77e:	90 e0       	ldi	r25, 0x00	; 0
 780:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <usart_init>
	XMEM_Init();
 784:	0e 94 b7 03 	call	0x76e	; 0x76e <XMEM_Init>
	calibrateJoystick();
 788:	0e 94 45 01 	call	0x28a	; 0x28a <calibrateJoystick>
	DDRB &= ~0b0011;
 78c:	87 b3       	in	r24, 0x17	; 23
 78e:	8c 7f       	andi	r24, 0xFC	; 252
 790:	87 bb       	out	0x17, r24	; 23
	oled_init();
 792:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <oled_init>
	oled_reset();
 796:	0e 94 4b 05 	call	0xa96	; 0xa96 <oled_reset>
	fdevopen(oled_putchar, usart_getchar);
 79a:	68 ee       	ldi	r22, 0xE8	; 232
 79c:	75 e0       	ldi	r23, 0x05	; 5
 79e:	8d e7       	ldi	r24, 0x7D	; 125
 7a0:	95 e0       	ldi	r25, 0x05	; 5
 7a2:	0e 94 71 07 	call	0xee2	; 0xee2 <fdevopen>
	oled_reset();
 7a6:	0e 94 4b 05 	call	0xa96	; 0xa96 <oled_reset>
	buttons_init();
 7aa:	0e 94 68 01 	call	0x2d0	; 0x2d0 <buttons_init>
	can_init();
 7ae:	0e 94 72 01 	call	0x2e4	; 0x2e4 <can_init>
 7b2:	08 95       	ret

000007b4 <main>:
}

int main(void) {
 7b4:	cf 93       	push	r28
 7b6:	df 93       	push	r29
 7b8:	cd b7       	in	r28, 0x3d	; 61
 7ba:	de b7       	in	r29, 0x3e	; 62
 7bc:	60 97       	sbiw	r28, 0x10	; 16
 7be:	0f b6       	in	r0, 0x3f	; 63
 7c0:	f8 94       	cli
 7c2:	de bf       	out	0x3e, r29	; 62
 7c4:	0f be       	out	0x3f, r0	; 63
 7c6:	cd bf       	out	0x3d, r28	; 61
	init();
 7c8:	0e 94 be 03 	call	0x77c	; 0x77c <init>
		printf_char("Beginning of main loop\n");
		
		
		
		
		char stri[5] = {1,2,3,4,5};
 7cc:	15 e0       	ldi	r17, 0x05	; 5
		
		//send a can massage:
		
		
		
		printf_char("Beginning of main loop\n");
 7ce:	87 e4       	ldi	r24, 0x47	; 71
 7d0:	92 e0       	ldi	r25, 0x02	; 2
 7d2:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
		
		
		
		
		char stri[5] = {1,2,3,4,5};
 7d6:	e6 e0       	ldi	r30, 0x06	; 6
 7d8:	f1 e0       	ldi	r31, 0x01	; 1
 7da:	de 01       	movw	r26, r28
 7dc:	1c 96       	adiw	r26, 0x0c	; 12
 7de:	81 2f       	mov	r24, r17
 7e0:	01 90       	ld	r0, Z+
 7e2:	0d 92       	st	X+, r0
 7e4:	8a 95       	dec	r24
 7e6:	e1 f7       	brne	.-8      	; 0x7e0 <main+0x2c>
		
		struct can_message msg = can_create_massage(42, 5, stri);
 7e8:	9e 01       	movw	r18, r28
 7ea:	24 5f       	subi	r18, 0xF4	; 244
 7ec:	3f 4f       	sbci	r19, 0xFF	; 255
 7ee:	41 2f       	mov	r20, r17
 7f0:	6a e2       	ldi	r22, 0x2A	; 42
 7f2:	70 e0       	ldi	r23, 0x00	; 0
 7f4:	ce 01       	movw	r24, r28
 7f6:	01 96       	adiw	r24, 0x01	; 1
 7f8:	0e 94 b5 01 	call	0x36a	; 0x36a <can_create_massage>

		can_send_message(&msg);
 7fc:	ce 01       	movw	r24, r28
 7fe:	01 96       	adiw	r24, 0x01	; 1
 800:	0e 94 93 02 	call	0x526	; 0x526 <can_send_message>
		struct can_message myName;		
		//printf_char("HELLO\n");

		char status = mcp_readStatus();
 804:	0e 94 78 04 	call	0x8f0	; 0x8f0 <mcp_readStatus>
 808:	e2 cf       	rjmp	.-60     	; 0x7ce <main+0x1a>

0000080a <mcp_reset>:
	mcp_reset();
	mcp_enable_interrupt();	
}

void mcp_reset() {
	spi_startTransmision();
 80a:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	spi_transmitByte(MCP_RESET);
 80e:	80 ec       	ldi	r24, 0xC0	; 192
 810:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_endTransmision();
 814:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
 818:	08 95       	ret

0000081a <mcp_read>:
}

void mcp_read(char address, char* outputArray, int length) {
 81a:	ef 92       	push	r14
 81c:	ff 92       	push	r15
 81e:	0f 93       	push	r16
 820:	1f 93       	push	r17
 822:	cf 93       	push	r28
 824:	df 93       	push	r29
 826:	c8 2f       	mov	r28, r24
 828:	7b 01       	movw	r14, r22
 82a:	8a 01       	movw	r16, r20
	spi_startTransmision();
 82c:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	
	spi_transmitByte(MCP_READ);
 830:	83 e0       	ldi	r24, 0x03	; 3
 832:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_transmitByte(address);
 836:	8c 2f       	mov	r24, r28
 838:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	

	for(int i = 0; i < length; ++i){
 83c:	10 16       	cp	r1, r16
 83e:	11 06       	cpc	r1, r17
 840:	4c f4       	brge	.+18     	; 0x854 <mcp_read+0x3a>
 842:	e7 01       	movw	r28, r14
 844:	0e 0d       	add	r16, r14
 846:	1f 1d       	adc	r17, r15
		outputArray[i] = spi_readByte();
 848:	0e 94 de 05 	call	0xbbc	; 0xbbc <spi_readByte>
 84c:	89 93       	st	Y+, r24
	
	spi_transmitByte(MCP_READ);
	spi_transmitByte(address);
	

	for(int i = 0; i < length; ++i){
 84e:	c0 17       	cp	r28, r16
 850:	d1 07       	cpc	r29, r17
 852:	d1 f7       	brne	.-12     	; 0x848 <mcp_read+0x2e>
			//printf_int(outputArray[i]);
			//printf_char("\n");
		}
	}
	
	spi_endTransmision();
 854:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
}
 858:	df 91       	pop	r29
 85a:	cf 91       	pop	r28
 85c:	1f 91       	pop	r17
 85e:	0f 91       	pop	r16
 860:	ff 90       	pop	r15
 862:	ef 90       	pop	r14
 864:	08 95       	ret

00000866 <mcp_write>:

void mcp_write(char adress, char* data, int length) {
 866:	ef 92       	push	r14
 868:	ff 92       	push	r15
 86a:	0f 93       	push	r16
 86c:	1f 93       	push	r17
 86e:	cf 93       	push	r28
 870:	df 93       	push	r29
 872:	c8 2f       	mov	r28, r24
 874:	7b 01       	movw	r14, r22
 876:	8a 01       	movw	r16, r20
	spi_startTransmision();
 878:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	
	spi_transmitByte(MCP_WRITE);
 87c:	82 e0       	ldi	r24, 0x02	; 2
 87e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_transmitByte(adress);
 882:	8c 2f       	mov	r24, r28
 884:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	
	for(int i = 0; i < length; ++i){
 888:	10 16       	cp	r1, r16
 88a:	11 06       	cpc	r1, r17
 88c:	4c f4       	brge	.+18     	; 0x8a0 <mcp_write+0x3a>
 88e:	e7 01       	movw	r28, r14
 890:	0e 0d       	add	r16, r14
 892:	1f 1d       	adc	r17, r15
		spi_transmitByte(data[i]);
 894:	89 91       	ld	r24, Y+
 896:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_startTransmision();
	
	spi_transmitByte(MCP_WRITE);
	spi_transmitByte(adress);
	
	for(int i = 0; i < length; ++i){
 89a:	c0 17       	cp	r28, r16
 89c:	d1 07       	cpc	r29, r17
 89e:	d1 f7       	brne	.-12     	; 0x894 <mcp_write+0x2e>
		spi_transmitByte(data[i]);
	}
	
	spi_endTransmision();
 8a0:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
}
 8a4:	df 91       	pop	r29
 8a6:	cf 91       	pop	r28
 8a8:	1f 91       	pop	r17
 8aa:	0f 91       	pop	r16
 8ac:	ff 90       	pop	r15
 8ae:	ef 90       	pop	r14
 8b0:	08 95       	ret

000008b2 <mcp_requestToSend>:

void mcp_requestToSend(enum TRANSMIT_BUFFER txb){
 8b2:	cf 93       	push	r28
 8b4:	c8 2f       	mov	r28, r24
	spi_startTransmision();
 8b6:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	
	if(txb == TXB0) {
 8ba:	c1 11       	cpse	r28, r1
 8bc:	04 c0       	rjmp	.+8      	; 0x8c6 <mcp_requestToSend+0x14>
		spi_transmitByte(MCP_RTS_TX0);	
 8be:	81 e8       	ldi	r24, 0x81	; 129
 8c0:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
 8c4:	11 c0       	rjmp	.+34     	; 0x8e8 <mcp_requestToSend+0x36>
	} else if(txb == TXB1) {
 8c6:	c1 30       	cpi	r28, 0x01	; 1
 8c8:	21 f4       	brne	.+8      	; 0x8d2 <mcp_requestToSend+0x20>
		spi_transmitByte(MCP_RTS_TX1);	
 8ca:	82 e8       	ldi	r24, 0x82	; 130
 8cc:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
 8d0:	0b c0       	rjmp	.+22     	; 0x8e8 <mcp_requestToSend+0x36>
	} else if(txb == TXB2) {
 8d2:	c2 30       	cpi	r28, 0x02	; 2
 8d4:	21 f4       	brne	.+8      	; 0x8de <mcp_requestToSend+0x2c>
		spi_transmitByte(MCP_RTS_TX2);	
 8d6:	84 e8       	ldi	r24, 0x84	; 132
 8d8:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
 8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <mcp_requestToSend+0x36>
	} else if(txb == TXBALL) {
 8de:	c3 30       	cpi	r28, 0x03	; 3
 8e0:	19 f4       	brne	.+6      	; 0x8e8 <mcp_requestToSend+0x36>
		spi_transmitByte(MCP_RTS_ALL);	
 8e2:	87 e8       	ldi	r24, 0x87	; 135
 8e4:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	}
	
	spi_endTransmision();
 8e8:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
}
 8ec:	cf 91       	pop	r28
 8ee:	08 95       	ret

000008f0 <mcp_readStatus>:

char mcp_readStatus() {
 8f0:	cf 93       	push	r28
	//allows single instruction access to some of the often used status bits (for message reception and transmission)
	spi_startTransmision();
 8f2:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	spi_transmitByte(MCP_READ_STATUS);
 8f6:	80 ea       	ldi	r24, 0xA0	; 160
 8f8:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	printf_char("HI\n");
 8fc:	8f e5       	ldi	r24, 0x5F	; 95
 8fe:	92 e0       	ldi	r25, 0x02	; 2
 900:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	char tmp = spi_readByte();
 904:	0e 94 de 05 	call	0xbbc	; 0xbbc <spi_readByte>
 908:	c8 2f       	mov	r28, r24
	printf_char("HI\n");
 90a:	8f e5       	ldi	r24, 0x5F	; 95
 90c:	92 e0       	ldi	r25, 0x02	; 2
 90e:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	spi_endTransmision();
 912:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
	//printf_char("read_Status: ");
	//printf_int(tmp);
	//printf_char("\n");
	
	return tmp;
}
 916:	8c 2f       	mov	r24, r28
 918:	cf 91       	pop	r28
 91a:	08 95       	ret

0000091c <mcp_bitModify>:
	status = status>>1; // We want to read register 1-3
	status &= 0x07; // Makes all other bits 0
	printf_int(status);
}

void mcp_bitModify(char adress, char mask, char data) {
 91c:	1f 93       	push	r17
 91e:	cf 93       	push	r28
 920:	df 93       	push	r29
 922:	18 2f       	mov	r17, r24
 924:	d6 2f       	mov	r29, r22
 926:	c4 2f       	mov	r28, r20
	spi_startTransmision();
 928:	0e 94 d6 05 	call	0xbac	; 0xbac <spi_startTransmision>
	spi_transmitByte(MCP_BITMOD);
 92c:	85 e0       	ldi	r24, 0x05	; 5
 92e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_transmitByte(adress);
 932:	81 2f       	mov	r24, r17
 934:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_transmitByte(mask);
 938:	8d 2f       	mov	r24, r29
 93a:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_transmitByte(data);
 93e:	8c 2f       	mov	r24, r28
 940:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	spi_endTransmision();
 944:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <spi_endTransmision>
}
 948:	df 91       	pop	r29
 94a:	cf 91       	pop	r28
 94c:	1f 91       	pop	r17
 94e:	08 95       	ret

00000950 <mcp_enable_interrupt>:

void mcp_enable_interrupt() {
	//SET_BIT(DDRE, PE0); //SET PE0 input
	SET_BIT(MCUCR, ISC11);
 950:	85 b7       	in	r24, 0x35	; 53
 952:	88 60       	ori	r24, 0x08	; 8
 954:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR, ISC10); 
 956:	85 b7       	in	r24, 0x35	; 53
 958:	8b 7f       	andi	r24, 0xFB	; 251
 95a:	85 bf       	out	0x35, r24	; 53
	SET_BIT(GICR, INT1);
 95c:	8b b7       	in	r24, 0x3b	; 59
 95e:	80 68       	ori	r24, 0x80	; 128
 960:	8b bf       	out	0x3b, r24	; 59

	mcp_bitModify(MCP_CANINTE, MCP_RX0IE | MCP_RX1IE, MCP_RX0IE | MCP_RX1IE); // Set the bits in MCU to get receive interrupts and transmit interrupts for buffer 0
 962:	43 e0       	ldi	r20, 0x03	; 3
 964:	63 e0       	ldi	r22, 0x03	; 3
 966:	8b e2       	ldi	r24, 0x2B	; 43
 968:	0e 94 8e 04 	call	0x91c	; 0x91c <mcp_bitModify>

	sei(); // Enable global interrupts by setting global interrupt enable bit in SREG
 96c:	78 94       	sei
 96e:	08 95       	ret

00000970 <mcp_init>:
#include "mcp.h"
#include "../SPI/spi.h"
#include "avr/interrupt.h"

void mcp_init() {
	mcp_reset();
 970:	0e 94 05 04 	call	0x80a	; 0x80a <mcp_reset>
	mcp_enable_interrupt();	
 974:	0e 94 a8 04 	call	0x950	; 0x950 <mcp_enable_interrupt>
 978:	08 95       	ret

0000097a <__vector_default>:
}



ISR (BADISR_vect)    // Timer1 ISR 
{
 97a:	1f 92       	push	r1
 97c:	0f 92       	push	r0
 97e:	0f b6       	in	r0, 0x3f	; 63
 980:	0f 92       	push	r0
 982:	11 24       	eor	r1, r1
 984:	2f 93       	push	r18
 986:	3f 93       	push	r19
 988:	4f 93       	push	r20
 98a:	5f 93       	push	r21
 98c:	6f 93       	push	r22
 98e:	7f 93       	push	r23
 990:	8f 93       	push	r24
 992:	9f 93       	push	r25
 994:	af 93       	push	r26
 996:	bf 93       	push	r27
 998:	ef 93       	push	r30
 99a:	ff 93       	push	r31

	printf_char("UNIMPLEMENTED INTERRUPT\t");
 99c:	83 e6       	ldi	r24, 0x63	; 99
 99e:	92 e0       	ldi	r25, 0x02	; 2
 9a0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	int temp = GIFR;
 9a4:	8a b7       	in	r24, 0x3a	; 58
	printf_int(temp);
 9a6:	90 e0       	ldi	r25, 0x00	; 0
 9a8:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	printf_char("\n");
 9ac:	81 ec       	ldi	r24, 0xC1	; 193
 9ae:	91 e0       	ldi	r25, 0x01	; 1
 9b0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <printf_char>
	sei();
 9b4:	78 94       	sei
 9b6:	ff 91       	pop	r31
 9b8:	ef 91       	pop	r30
 9ba:	bf 91       	pop	r27
 9bc:	af 91       	pop	r26
 9be:	9f 91       	pop	r25
 9c0:	8f 91       	pop	r24
 9c2:	7f 91       	pop	r23
 9c4:	6f 91       	pop	r22
 9c6:	5f 91       	pop	r21
 9c8:	4f 91       	pop	r20
 9ca:	3f 91       	pop	r19
 9cc:	2f 91       	pop	r18
 9ce:	0f 90       	pop	r0
 9d0:	0f be       	out	0x3f, r0	; 63
 9d2:	0f 90       	pop	r0
 9d4:	1f 90       	pop	r1
 9d6:	18 95       	reti

000009d8 <fonts_getStrip>:
 */ 

#include "fonts.h"

unsigned char fonts_getStrip(char character, char stripNo){
	character -= ' ';
 9d8:	80 52       	subi	r24, 0x20	; 32
	unsigned char temp = (pgm_read_word(&font5[character][stripNo]));
 9da:	90 e0       	ldi	r25, 0x00	; 0
 9dc:	fc 01       	movw	r30, r24
 9de:	ee 0f       	add	r30, r30
 9e0:	ff 1f       	adc	r31, r31
 9e2:	ee 0f       	add	r30, r30
 9e4:	ff 1f       	adc	r31, r31
 9e6:	e8 0f       	add	r30, r24
 9e8:	f9 1f       	adc	r31, r25
 9ea:	e6 0f       	add	r30, r22
 9ec:	f1 1d       	adc	r31, r1
 9ee:	e0 59       	subi	r30, 0x90	; 144
 9f0:	ff 4f       	sbci	r31, 0xFF	; 255
 9f2:	85 91       	lpm	r24, Z+
 9f4:	94 91       	lpm	r25, Z
	return temp;
 9f6:	08 95       	ret

000009f8 <oled_init>:
	oled_write_c(0xaf);  //display on
}

void oled_write_c(int input) {
	volatile char* ptr = OLED_C;
	*ptr = (input);
 9f8:	e0 e0       	ldi	r30, 0x00	; 0
 9fa:	f0 e1       	ldi	r31, 0x10	; 16
 9fc:	8e ea       	ldi	r24, 0xAE	; 174
 9fe:	80 83       	st	Z, r24
 a00:	81 ea       	ldi	r24, 0xA1	; 161
 a02:	80 83       	st	Z, r24
 a04:	8a ed       	ldi	r24, 0xDA	; 218
 a06:	80 83       	st	Z, r24
 a08:	82 e1       	ldi	r24, 0x12	; 18
 a0a:	80 83       	st	Z, r24
 a0c:	88 ec       	ldi	r24, 0xC8	; 200
 a0e:	80 83       	st	Z, r24
 a10:	88 ea       	ldi	r24, 0xA8	; 168
 a12:	80 83       	st	Z, r24
 a14:	8f e3       	ldi	r24, 0x3F	; 63
 a16:	80 83       	st	Z, r24
 a18:	85 ed       	ldi	r24, 0xD5	; 213
 a1a:	80 83       	st	Z, r24
 a1c:	80 e8       	ldi	r24, 0x80	; 128
 a1e:	80 83       	st	Z, r24
 a20:	81 e8       	ldi	r24, 0x81	; 129
 a22:	80 83       	st	Z, r24
 a24:	80 e5       	ldi	r24, 0x50	; 80
 a26:	80 83       	st	Z, r24
 a28:	89 ed       	ldi	r24, 0xD9	; 217
 a2a:	80 83       	st	Z, r24
 a2c:	81 e2       	ldi	r24, 0x21	; 33
 a2e:	80 83       	st	Z, r24
 a30:	80 e2       	ldi	r24, 0x20	; 32
 a32:	80 83       	st	Z, r24
 a34:	82 e0       	ldi	r24, 0x02	; 2
 a36:	80 83       	st	Z, r24
 a38:	8b ed       	ldi	r24, 0xDB	; 219
 a3a:	80 83       	st	Z, r24
 a3c:	80 e3       	ldi	r24, 0x30	; 48
 a3e:	80 83       	st	Z, r24
 a40:	8d ea       	ldi	r24, 0xAD	; 173
 a42:	80 83       	st	Z, r24
 a44:	10 82       	st	Z, r1
 a46:	84 ea       	ldi	r24, 0xA4	; 164
 a48:	80 83       	st	Z, r24
 a4a:	86 ea       	ldi	r24, 0xA6	; 166
 a4c:	80 83       	st	Z, r24
 a4e:	8f ea       	ldi	r24, 0xAF	; 175
 a50:	80 83       	st	Z, r24
 a52:	08 95       	ret

00000a54 <oled_goto_line>:
		oled_clear_line(i);
	}
}

void oled_goto_line(char line) {
	if(line < 8) {
 a54:	88 30       	cpi	r24, 0x08	; 8
 a56:	90 f4       	brcc	.+36     	; 0xa7c <oled_goto_line+0x28>
		oled_write_c(0xB0 + line);
 a58:	90 e0       	ldi	r25, 0x00	; 0
 a5a:	9c 01       	movw	r18, r24
 a5c:	20 55       	subi	r18, 0x50	; 80
 a5e:	3f 4f       	sbci	r19, 0xFF	; 255
	oled_write_c(0xaf);  //display on
}

void oled_write_c(int input) {
	volatile char* ptr = OLED_C;
	*ptr = (input);
 a60:	e0 e0       	ldi	r30, 0x00	; 0
 a62:	f0 e1       	ldi	r31, 0x10	; 16
 a64:	20 83       	st	Z, r18
 a66:	10 82       	st	Z, r1
 a68:	20 e1       	ldi	r18, 0x10	; 16
 a6a:	20 83       	st	Z, r18
void oled_goto_line(char line) {
	if(line < 8) {
		oled_write_c(0xB0 + line);
		oled_write_c(0x00); //set lower column
		oled_write_c(0x10);
		CURRENT_LINE = line;
 a6c:	90 93 80 02 	sts	0x0280, r25
 a70:	80 93 7f 02 	sts	0x027F, r24
		CURRENT_COL = 0;
 a74:	10 92 7e 02 	sts	0x027E, r1
 a78:	10 92 7d 02 	sts	0x027D, r1
 a7c:	08 95       	ret

00000a7e <oled_clear_line>:
		CURRENT_COL = column;
	}
}

void oled_clear_line(char line) {
	oled_goto_line(line);
 a7e:	0e 94 2a 05 	call	0xa54	; 0xa54 <oled_goto_line>
 a82:	80 e8       	ldi	r24, 0x80	; 128
 a84:	90 e0       	ldi	r25, 0x00	; 0
	oled_print_strip(temp);
}

void oled_print_strip(char input) {
	volatile char* ptr = OLED_D;
	*ptr = input;
 a86:	e0 e0       	ldi	r30, 0x00	; 0
 a88:	f2 e1       	ldi	r31, 0x12	; 18
 a8a:	21 e0       	ldi	r18, 0x01	; 1
 a8c:	20 83       	st	Z, r18
 a8e:	01 97       	sbiw	r24, 0x01	; 1
	}
}

void oled_clear_line(char line) {
	oled_goto_line(line);
	for(int i = 0; i < 128; i++) {
 a90:	00 97       	sbiw	r24, 0x00	; 0
 a92:	e1 f7       	brne	.-8      	; 0xa8c <oled_clear_line+0xe>
		oled_print_strip(0x01);
	}
}
 a94:	08 95       	ret

00000a96 <oled_reset>:
void oled_write_c(int input) {
	volatile char* ptr = OLED_C;
	*ptr = (input);
}

void oled_reset() {
 a96:	cf 93       	push	r28
 a98:	c0 e0       	ldi	r28, 0x00	; 0
	for(int i = 0; i < 8; i++) {
		oled_clear_line(i);
 a9a:	8c 2f       	mov	r24, r28
 a9c:	0e 94 3f 05 	call	0xa7e	; 0xa7e <oled_clear_line>
 aa0:	cf 5f       	subi	r28, 0xFF	; 255
	volatile char* ptr = OLED_C;
	*ptr = (input);
}

void oled_reset() {
	for(int i = 0; i < 8; i++) {
 aa2:	c8 30       	cpi	r28, 0x08	; 8
 aa4:	d1 f7       	brne	.-12     	; 0xa9a <oled_reset+0x4>
		oled_clear_line(i);
	}
}
 aa6:	cf 91       	pop	r28
 aa8:	08 95       	ret

00000aaa <oled_printchar>:
void oled_print_strip(char input) {
	volatile char* ptr = OLED_D;
	*ptr = input;
}

void oled_printchar(char input) {
 aaa:	df 92       	push	r13
 aac:	ef 92       	push	r14
 aae:	ff 92       	push	r15
 ab0:	0f 93       	push	r16
 ab2:	1f 93       	push	r17
 ab4:	cf 93       	push	r28
 ab6:	df 93       	push	r29
	char temp;
	char mask = 0x00;

	if (printmode == INVERSE){
 ab8:	91 e0       	ldi	r25, 0x01	; 1
 aba:	20 91 7c 02 	lds	r18, 0x027C
 abe:	21 30       	cpi	r18, 0x01	; 1
 ac0:	09 f0       	breq	.+2      	; 0xac4 <oled_printchar+0x1a>
 ac2:	90 e0       	ldi	r25, 0x00	; 0
 ac4:	d9 2e       	mov	r13, r25
 ac6:	d1 94       	neg	r13
		mask = 0xFF;
	}
	for(int i =0; i<5 ; ++i){
 ac8:	c0 e0       	ldi	r28, 0x00	; 0
 aca:	d0 e0       	ldi	r29, 0x00	; 0
		temp = fonts_getStrip(input, i);
 acc:	e8 2e       	mov	r14, r24
 ace:	f1 2c       	mov	r15, r1
	oled_print_strip(temp);
}

void oled_print_strip(char input) {
	volatile char* ptr = OLED_D;
	*ptr = input;
 ad0:	00 e0       	ldi	r16, 0x00	; 0
 ad2:	12 e1       	ldi	r17, 0x12	; 18

	if (printmode == INVERSE){
		mask = 0xFF;
	}
	for(int i =0; i<5 ; ++i){
		temp = fonts_getStrip(input, i);
 ad4:	be 01       	movw	r22, r28
 ad6:	c7 01       	movw	r24, r14
 ad8:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <fonts_getStrip>
		oled_print_strip(temp^mask);
 adc:	8d 25       	eor	r24, r13
	oled_print_strip(temp);
}

void oled_print_strip(char input) {
	volatile char* ptr = OLED_D;
	*ptr = input;
 ade:	f8 01       	movw	r30, r16
 ae0:	80 83       	st	Z, r24
	char mask = 0x00;

	if (printmode == INVERSE){
		mask = 0xFF;
	}
	for(int i =0; i<5 ; ++i){
 ae2:	21 96       	adiw	r28, 0x01	; 1
 ae4:	c5 30       	cpi	r28, 0x05	; 5
 ae6:	d1 05       	cpc	r29, r1
 ae8:	a9 f7       	brne	.-22     	; 0xad4 <oled_printchar+0x2a>
		temp = fonts_getStrip(input, i);
		oled_print_strip(temp^mask);
	}
}
 aea:	df 91       	pop	r29
 aec:	cf 91       	pop	r28
 aee:	1f 91       	pop	r17
 af0:	0f 91       	pop	r16
 af2:	ff 90       	pop	r15
 af4:	ef 90       	pop	r14
 af6:	df 90       	pop	r13
 af8:	08 95       	ret

00000afa <oled_putchar>:

int oled_putchar(unsigned char input) {
 afa:	cf 93       	push	r28
 afc:	c8 2f       	mov	r28, r24
	if(input =='\n' || CURRENT_COL/5 >=25){
 afe:	8a 30       	cpi	r24, 0x0A	; 10
 b00:	41 f0       	breq	.+16     	; 0xb12 <oled_putchar+0x18>
 b02:	20 91 7d 02 	lds	r18, 0x027D
 b06:	30 91 7e 02 	lds	r19, 0x027E
 b0a:	2d 37       	cpi	r18, 0x7D	; 125
 b0c:	31 05       	cpc	r19, r1
 b0e:	0c f4       	brge	.+2      	; 0xb12 <oled_putchar+0x18>
 b10:	43 c0       	rjmp	.+134    	; 0xb98 <oled_putchar+0x9e>
		CURRENT_LINE = ++CURRENT_LINE%8;
 b12:	20 91 7f 02 	lds	r18, 0x027F
 b16:	30 91 80 02 	lds	r19, 0x0280
 b1a:	2f 5f       	subi	r18, 0xFF	; 255
 b1c:	3f 4f       	sbci	r19, 0xFF	; 255
 b1e:	27 70       	andi	r18, 0x07	; 7
 b20:	30 78       	andi	r19, 0x80	; 128
 b22:	33 23       	and	r19, r19
 b24:	34 f4       	brge	.+12     	; 0xb32 <oled_putchar+0x38>
 b26:	21 50       	subi	r18, 0x01	; 1
 b28:	31 09       	sbc	r19, r1
 b2a:	28 6f       	ori	r18, 0xF8	; 248
 b2c:	3f 6f       	ori	r19, 0xFF	; 255
 b2e:	2f 5f       	subi	r18, 0xFF	; 255
 b30:	3f 4f       	sbci	r19, 0xFF	; 255
 b32:	30 93 80 02 	sts	0x0280, r19
 b36:	20 93 7f 02 	sts	0x027F, r18
		for (int i = CURRENT_COL; i < 128; ++i){
 b3a:	20 91 7d 02 	lds	r18, 0x027D
 b3e:	30 91 7e 02 	lds	r19, 0x027E
 b42:	20 38       	cpi	r18, 0x80	; 128
 b44:	31 05       	cpc	r19, r1
 b46:	44 f4       	brge	.+16     	; 0xb58 <oled_putchar+0x5e>
	oled_print_strip(temp);
}

void oled_print_strip(char input) {
	volatile char* ptr = OLED_D;
	*ptr = input;
 b48:	e0 e0       	ldi	r30, 0x00	; 0
 b4a:	f2 e1       	ldi	r31, 0x12	; 18
 b4c:	10 82       	st	Z, r1
}

int oled_putchar(unsigned char input) {
	if(input =='\n' || CURRENT_COL/5 >=25){
		CURRENT_LINE = ++CURRENT_LINE%8;
		for (int i = CURRENT_COL; i < 128; ++i){
 b4e:	2f 5f       	subi	r18, 0xFF	; 255
 b50:	3f 4f       	sbci	r19, 0xFF	; 255
 b52:	20 38       	cpi	r18, 0x80	; 128
 b54:	31 05       	cpc	r19, r1
 b56:	d1 f7       	brne	.-12     	; 0xb4c <oled_putchar+0x52>
			oled_print_strip(0x00);
		}
		oled_goto_line(CURRENT_LINE);
 b58:	80 91 7f 02 	lds	r24, 0x027F
 b5c:	0e 94 2a 05 	call	0xa54	; 0xa54 <oled_goto_line>
		CURRENT_COL=0;
 b60:	10 92 7e 02 	sts	0x027E, r1
 b64:	10 92 7d 02 	sts	0x027D, r1
	}
	usart_putchar(input);
 b68:	8c 2f       	mov	r24, r28
 b6a:	0e 94 ed 05 	call	0xbda	; 0xbda <usart_putchar>
	if(input =='\n') return input;
 b6e:	ca 30       	cpi	r28, 0x0A	; 10
 b70:	81 f0       	breq	.+32     	; 0xb92 <oled_putchar+0x98>
	oled_printchar(input);
 b72:	8c 2f       	mov	r24, r28
 b74:	0e 94 55 05 	call	0xaaa	; 0xaaa <oled_printchar>

	CURRENT_COL+=5;
 b78:	20 91 7d 02 	lds	r18, 0x027D
 b7c:	30 91 7e 02 	lds	r19, 0x027E
 b80:	2b 5f       	subi	r18, 0xFB	; 251
 b82:	3f 4f       	sbci	r19, 0xFF	; 255
 b84:	30 93 7e 02 	sts	0x027E, r19
 b88:	20 93 7d 02 	sts	0x027D, r18
	return input;
 b8c:	8c 2f       	mov	r24, r28
 b8e:	90 e0       	ldi	r25, 0x00	; 0
 b90:	06 c0       	rjmp	.+12     	; 0xb9e <oled_putchar+0xa4>
		}
		oled_goto_line(CURRENT_LINE);
		CURRENT_COL=0;
	}
	usart_putchar(input);
	if(input =='\n') return input;
 b92:	8a e0       	ldi	r24, 0x0A	; 10
 b94:	90 e0       	ldi	r25, 0x00	; 0
 b96:	03 c0       	rjmp	.+6      	; 0xb9e <oled_putchar+0xa4>
			oled_print_strip(0x00);
		}
		oled_goto_line(CURRENT_LINE);
		CURRENT_COL=0;
	}
	usart_putchar(input);
 b98:	0e 94 ed 05 	call	0xbda	; 0xbda <usart_putchar>
 b9c:	ea cf       	rjmp	.-44     	; 0xb72 <oled_putchar+0x78>
	if(input =='\n') return input;
	oled_printchar(input);

	CURRENT_COL+=5;
	return input;
}
 b9e:	cf 91       	pop	r28
 ba0:	08 95       	ret

00000ba2 <spi_init>:

#include "spi.h"

void spi_init() {
	/* Set MOSI and SCK and SS output, all others input */
	DDRB = (1<<PB2)|(1<<PB1)|(1<<PB0);
 ba2:	87 e0       	ldi	r24, 0x07	; 7
 ba4:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 ba6:	81 e5       	ldi	r24, 0x51	; 81
 ba8:	8d b9       	out	0x0d, r24	; 13
 baa:	08 95       	ret

00000bac <spi_startTransmision>:
}

void spi_startTransmision() {
	//put SS-Signal to low
	CLEAR_BIT(PORTB, PB4);
 bac:	c4 98       	cbi	0x18, 4	; 24
 bae:	08 95       	ret

00000bb0 <spi_endTransmision>:
}

void spi_endTransmision() {
	//put SS-Signal to high
	SET_BIT(PORTB, PB4);
 bb0:	c4 9a       	sbi	0x18, 4	; 24
 bb2:	08 95       	ret

00000bb4 <spi_transmitByte>:
}

void spi_transmitByte(char byte) {
	
	SPDR = byte;
 bb4:	8f b9       	out	0x0f, r24	; 15
	while( ! (SPSR & (1<<SPIF))) {
 bb6:	77 9b       	sbis	0x0e, 7	; 14
 bb8:	fe cf       	rjmp	.-4      	; 0xbb6 <spi_transmitByte+0x2>
	}
}
 bba:	08 95       	ret

00000bbc <spi_readByte>:

char spi_readByte() {
	
	spi_transmitByte(0x00);
 bbc:	80 e0       	ldi	r24, 0x00	; 0
 bbe:	0e 94 da 05 	call	0xbb4	; 0xbb4 <spi_transmitByte>
	char tmp = SPDR;
 bc2:	8f b1       	in	r24, 0x0f	; 15
	
	return tmp;
}
 bc4:	08 95       	ret

00000bc6 <usart_init>:

#include "usart.h"

void usart_init( unsigned int ubrr ) {
	// set the baud rate
	UBRR0H = (unsigned char)(ubrr>>8);
 bc6:	90 bd       	out	0x20, r25	; 32
	UBRR0L = (unsigned char)(ubrr);
 bc8:	89 b9       	out	0x09, r24	; 9
	// enable reciever and transmitter
	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
 bca:	88 e1       	ldi	r24, 0x18	; 24
 bcc:	8a b9       	out	0x0a, r24	; 10
 bce:	08 95       	ret

00000bd0 <usart_getchar>:
	//fdevopen(USART_putchar, USART_getchar);
}

int usart_getchar() {
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) );
 bd0:	5f 9b       	sbis	0x0b, 7	; 11
 bd2:	fe cf       	rjmp	.-4      	; 0xbd0 <usart_getchar>
	/* Get and return received data from buffer */
	return UDR0;
 bd4:	8c b1       	in	r24, 0x0c	; 12
}
 bd6:	90 e0       	ldi	r25, 0x00	; 0
 bd8:	08 95       	ret

00000bda <usart_putchar>:

int usart_putchar(unsigned char data) {
	// wait for empty transmit buffer
	while (!(UCSR0A & (1<<UDRE0)));
 bda:	5d 9b       	sbis	0x0b, 5	; 11
 bdc:	fe cf       	rjmp	.-4      	; 0xbda <usart_putchar>
	// put data into buffer, sends the data
	UDR0 = data;
 bde:	8c b9       	out	0x0c, r24	; 12
	return data;
}
 be0:	90 e0       	ldi	r25, 0x00	; 0
 be2:	08 95       	ret

00000be4 <printf_char>:

void printf_char(char* string) {
 be4:	cf 93       	push	r28
 be6:	df 93       	push	r29
 be8:	ec 01       	movw	r28, r24
	for (int i = 0; string[i] != '\0'; ++i) {
 bea:	88 81       	ld	r24, Y
 bec:	88 23       	and	r24, r24
 bee:	31 f0       	breq	.+12     	; 0xbfc <printf_char+0x18>
 bf0:	21 96       	adiw	r28, 0x01	; 1
		usart_putchar(string[i]);
 bf2:	0e 94 ed 05 	call	0xbda	; 0xbda <usart_putchar>
	UDR0 = data;
	return data;
}

void printf_char(char* string) {
	for (int i = 0; string[i] != '\0'; ++i) {
 bf6:	89 91       	ld	r24, Y+
 bf8:	81 11       	cpse	r24, r1
 bfa:	fb cf       	rjmp	.-10     	; 0xbf2 <printf_char+0xe>
		usart_putchar(string[i]);
	}
}
 bfc:	df 91       	pop	r29
 bfe:	cf 91       	pop	r28
 c00:	08 95       	ret

00000c02 <printf_int>:

void printf_int(int input) {
 c02:	cf 93       	push	r28
 c04:	df 93       	push	r29
 c06:	ec 01       	movw	r28, r24
	if (input<0){
 c08:	99 23       	and	r25, r25
 c0a:	34 f4       	brge	.+12     	; 0xc18 <printf_int+0x16>
		input *=-1;
 c0c:	d1 95       	neg	r29
 c0e:	c1 95       	neg	r28
 c10:	d1 09       	sbc	r29, r1
		usart_putchar('-');
 c12:	8d e2       	ldi	r24, 0x2D	; 45
 c14:	0e 94 ed 05 	call	0xbda	; 0xbda <usart_putchar>
	}
	if(input/10 > 0)
 c18:	ca 30       	cpi	r28, 0x0A	; 10
 c1a:	d1 05       	cpc	r29, r1
 c1c:	44 f0       	brlt	.+16     	; 0xc2e <printf_int+0x2c>
	printf_int(input/10);
 c1e:	ce 01       	movw	r24, r28
 c20:	6a e0       	ldi	r22, 0x0A	; 10
 c22:	70 e0       	ldi	r23, 0x00	; 0
 c24:	0e 94 22 06 	call	0xc44	; 0xc44 <__divmodhi4>
 c28:	cb 01       	movw	r24, r22
 c2a:	0e 94 01 06 	call	0xc02	; 0xc02 <printf_int>
	usart_putchar((unsigned char) (input%10) + '0');
 c2e:	ce 01       	movw	r24, r28
 c30:	6a e0       	ldi	r22, 0x0A	; 10
 c32:	70 e0       	ldi	r23, 0x00	; 0
 c34:	0e 94 22 06 	call	0xc44	; 0xc44 <__divmodhi4>
 c38:	80 5d       	subi	r24, 0xD0	; 208
 c3a:	0e 94 ed 05 	call	0xbda	; 0xbda <usart_putchar>
}
 c3e:	df 91       	pop	r29
 c40:	cf 91       	pop	r28
 c42:	08 95       	ret

00000c44 <__divmodhi4>:
 c44:	97 fb       	bst	r25, 7
 c46:	07 2e       	mov	r0, r23
 c48:	16 f4       	brtc	.+4      	; 0xc4e <__divmodhi4+0xa>
 c4a:	00 94       	com	r0
 c4c:	07 d0       	rcall	.+14     	; 0xc5c <__divmodhi4_neg1>
 c4e:	77 fd       	sbrc	r23, 7
 c50:	09 d0       	rcall	.+18     	; 0xc64 <__divmodhi4_neg2>
 c52:	0e 94 36 06 	call	0xc6c	; 0xc6c <__udivmodhi4>
 c56:	07 fc       	sbrc	r0, 7
 c58:	05 d0       	rcall	.+10     	; 0xc64 <__divmodhi4_neg2>
 c5a:	3e f4       	brtc	.+14     	; 0xc6a <__divmodhi4_exit>

00000c5c <__divmodhi4_neg1>:
 c5c:	90 95       	com	r25
 c5e:	81 95       	neg	r24
 c60:	9f 4f       	sbci	r25, 0xFF	; 255
 c62:	08 95       	ret

00000c64 <__divmodhi4_neg2>:
 c64:	70 95       	com	r23
 c66:	61 95       	neg	r22
 c68:	7f 4f       	sbci	r23, 0xFF	; 255

00000c6a <__divmodhi4_exit>:
 c6a:	08 95       	ret

00000c6c <__udivmodhi4>:
 c6c:	aa 1b       	sub	r26, r26
 c6e:	bb 1b       	sub	r27, r27
 c70:	51 e1       	ldi	r21, 0x11	; 17
 c72:	07 c0       	rjmp	.+14     	; 0xc82 <__udivmodhi4_ep>

00000c74 <__udivmodhi4_loop>:
 c74:	aa 1f       	adc	r26, r26
 c76:	bb 1f       	adc	r27, r27
 c78:	a6 17       	cp	r26, r22
 c7a:	b7 07       	cpc	r27, r23
 c7c:	10 f0       	brcs	.+4      	; 0xc82 <__udivmodhi4_ep>
 c7e:	a6 1b       	sub	r26, r22
 c80:	b7 0b       	sbc	r27, r23

00000c82 <__udivmodhi4_ep>:
 c82:	88 1f       	adc	r24, r24
 c84:	99 1f       	adc	r25, r25
 c86:	5a 95       	dec	r21
 c88:	a9 f7       	brne	.-22     	; 0xc74 <__udivmodhi4_loop>
 c8a:	80 95       	com	r24
 c8c:	90 95       	com	r25
 c8e:	bc 01       	movw	r22, r24
 c90:	cd 01       	movw	r24, r26
 c92:	08 95       	ret

00000c94 <malloc>:
 c94:	cf 93       	push	r28
 c96:	df 93       	push	r29
 c98:	82 30       	cpi	r24, 0x02	; 2
 c9a:	91 05       	cpc	r25, r1
 c9c:	10 f4       	brcc	.+4      	; 0xca2 <malloc+0xe>
 c9e:	82 e0       	ldi	r24, 0x02	; 2
 ca0:	90 e0       	ldi	r25, 0x00	; 0
 ca2:	e0 91 8b 02 	lds	r30, 0x028B
 ca6:	f0 91 8c 02 	lds	r31, 0x028C
 caa:	20 e0       	ldi	r18, 0x00	; 0
 cac:	30 e0       	ldi	r19, 0x00	; 0
 cae:	a0 e0       	ldi	r26, 0x00	; 0
 cb0:	b0 e0       	ldi	r27, 0x00	; 0
 cb2:	30 97       	sbiw	r30, 0x00	; 0
 cb4:	39 f1       	breq	.+78     	; 0xd04 <malloc+0x70>
 cb6:	40 81       	ld	r20, Z
 cb8:	51 81       	ldd	r21, Z+1	; 0x01
 cba:	48 17       	cp	r20, r24
 cbc:	59 07       	cpc	r21, r25
 cbe:	b8 f0       	brcs	.+46     	; 0xcee <malloc+0x5a>
 cc0:	48 17       	cp	r20, r24
 cc2:	59 07       	cpc	r21, r25
 cc4:	71 f4       	brne	.+28     	; 0xce2 <malloc+0x4e>
 cc6:	82 81       	ldd	r24, Z+2	; 0x02
 cc8:	93 81       	ldd	r25, Z+3	; 0x03
 cca:	10 97       	sbiw	r26, 0x00	; 0
 ccc:	29 f0       	breq	.+10     	; 0xcd8 <malloc+0x44>
 cce:	13 96       	adiw	r26, 0x03	; 3
 cd0:	9c 93       	st	X, r25
 cd2:	8e 93       	st	-X, r24
 cd4:	12 97       	sbiw	r26, 0x02	; 2
 cd6:	2c c0       	rjmp	.+88     	; 0xd30 <malloc+0x9c>
 cd8:	90 93 8c 02 	sts	0x028C, r25
 cdc:	80 93 8b 02 	sts	0x028B, r24
 ce0:	27 c0       	rjmp	.+78     	; 0xd30 <malloc+0x9c>
 ce2:	21 15       	cp	r18, r1
 ce4:	31 05       	cpc	r19, r1
 ce6:	31 f0       	breq	.+12     	; 0xcf4 <malloc+0x60>
 ce8:	42 17       	cp	r20, r18
 cea:	53 07       	cpc	r21, r19
 cec:	18 f0       	brcs	.+6      	; 0xcf4 <malloc+0x60>
 cee:	a9 01       	movw	r20, r18
 cf0:	db 01       	movw	r26, r22
 cf2:	01 c0       	rjmp	.+2      	; 0xcf6 <malloc+0x62>
 cf4:	ef 01       	movw	r28, r30
 cf6:	9a 01       	movw	r18, r20
 cf8:	bd 01       	movw	r22, r26
 cfa:	df 01       	movw	r26, r30
 cfc:	02 80       	ldd	r0, Z+2	; 0x02
 cfe:	f3 81       	ldd	r31, Z+3	; 0x03
 d00:	e0 2d       	mov	r30, r0
 d02:	d7 cf       	rjmp	.-82     	; 0xcb2 <malloc+0x1e>
 d04:	21 15       	cp	r18, r1
 d06:	31 05       	cpc	r19, r1
 d08:	f9 f0       	breq	.+62     	; 0xd48 <malloc+0xb4>
 d0a:	28 1b       	sub	r18, r24
 d0c:	39 0b       	sbc	r19, r25
 d0e:	24 30       	cpi	r18, 0x04	; 4
 d10:	31 05       	cpc	r19, r1
 d12:	80 f4       	brcc	.+32     	; 0xd34 <malloc+0xa0>
 d14:	8a 81       	ldd	r24, Y+2	; 0x02
 d16:	9b 81       	ldd	r25, Y+3	; 0x03
 d18:	61 15       	cp	r22, r1
 d1a:	71 05       	cpc	r23, r1
 d1c:	21 f0       	breq	.+8      	; 0xd26 <malloc+0x92>
 d1e:	fb 01       	movw	r30, r22
 d20:	93 83       	std	Z+3, r25	; 0x03
 d22:	82 83       	std	Z+2, r24	; 0x02
 d24:	04 c0       	rjmp	.+8      	; 0xd2e <malloc+0x9a>
 d26:	90 93 8c 02 	sts	0x028C, r25
 d2a:	80 93 8b 02 	sts	0x028B, r24
 d2e:	fe 01       	movw	r30, r28
 d30:	32 96       	adiw	r30, 0x02	; 2
 d32:	44 c0       	rjmp	.+136    	; 0xdbc <malloc+0x128>
 d34:	fe 01       	movw	r30, r28
 d36:	e2 0f       	add	r30, r18
 d38:	f3 1f       	adc	r31, r19
 d3a:	81 93       	st	Z+, r24
 d3c:	91 93       	st	Z+, r25
 d3e:	22 50       	subi	r18, 0x02	; 2
 d40:	31 09       	sbc	r19, r1
 d42:	39 83       	std	Y+1, r19	; 0x01
 d44:	28 83       	st	Y, r18
 d46:	3a c0       	rjmp	.+116    	; 0xdbc <malloc+0x128>
 d48:	20 91 89 02 	lds	r18, 0x0289
 d4c:	30 91 8a 02 	lds	r19, 0x028A
 d50:	23 2b       	or	r18, r19
 d52:	41 f4       	brne	.+16     	; 0xd64 <malloc+0xd0>
 d54:	20 91 02 01 	lds	r18, 0x0102
 d58:	30 91 03 01 	lds	r19, 0x0103
 d5c:	30 93 8a 02 	sts	0x028A, r19
 d60:	20 93 89 02 	sts	0x0289, r18
 d64:	20 91 00 01 	lds	r18, 0x0100
 d68:	30 91 01 01 	lds	r19, 0x0101
 d6c:	21 15       	cp	r18, r1
 d6e:	31 05       	cpc	r19, r1
 d70:	41 f4       	brne	.+16     	; 0xd82 <malloc+0xee>
 d72:	2d b7       	in	r18, 0x3d	; 61
 d74:	3e b7       	in	r19, 0x3e	; 62
 d76:	40 91 04 01 	lds	r20, 0x0104
 d7a:	50 91 05 01 	lds	r21, 0x0105
 d7e:	24 1b       	sub	r18, r20
 d80:	35 0b       	sbc	r19, r21
 d82:	e0 91 89 02 	lds	r30, 0x0289
 d86:	f0 91 8a 02 	lds	r31, 0x028A
 d8a:	e2 17       	cp	r30, r18
 d8c:	f3 07       	cpc	r31, r19
 d8e:	a0 f4       	brcc	.+40     	; 0xdb8 <malloc+0x124>
 d90:	2e 1b       	sub	r18, r30
 d92:	3f 0b       	sbc	r19, r31
 d94:	28 17       	cp	r18, r24
 d96:	39 07       	cpc	r19, r25
 d98:	78 f0       	brcs	.+30     	; 0xdb8 <malloc+0x124>
 d9a:	ac 01       	movw	r20, r24
 d9c:	4e 5f       	subi	r20, 0xFE	; 254
 d9e:	5f 4f       	sbci	r21, 0xFF	; 255
 da0:	24 17       	cp	r18, r20
 da2:	35 07       	cpc	r19, r21
 da4:	48 f0       	brcs	.+18     	; 0xdb8 <malloc+0x124>
 da6:	4e 0f       	add	r20, r30
 da8:	5f 1f       	adc	r21, r31
 daa:	50 93 8a 02 	sts	0x028A, r21
 dae:	40 93 89 02 	sts	0x0289, r20
 db2:	81 93       	st	Z+, r24
 db4:	91 93       	st	Z+, r25
 db6:	02 c0       	rjmp	.+4      	; 0xdbc <malloc+0x128>
 db8:	e0 e0       	ldi	r30, 0x00	; 0
 dba:	f0 e0       	ldi	r31, 0x00	; 0
 dbc:	cf 01       	movw	r24, r30
 dbe:	df 91       	pop	r29
 dc0:	cf 91       	pop	r28
 dc2:	08 95       	ret

00000dc4 <free>:
 dc4:	cf 93       	push	r28
 dc6:	df 93       	push	r29
 dc8:	00 97       	sbiw	r24, 0x00	; 0
 dca:	09 f4       	brne	.+2      	; 0xdce <free+0xa>
 dcc:	87 c0       	rjmp	.+270    	; 0xedc <free+0x118>
 dce:	fc 01       	movw	r30, r24
 dd0:	32 97       	sbiw	r30, 0x02	; 2
 dd2:	13 82       	std	Z+3, r1	; 0x03
 dd4:	12 82       	std	Z+2, r1	; 0x02
 dd6:	c0 91 8b 02 	lds	r28, 0x028B
 dda:	d0 91 8c 02 	lds	r29, 0x028C
 dde:	20 97       	sbiw	r28, 0x00	; 0
 de0:	81 f4       	brne	.+32     	; 0xe02 <free+0x3e>
 de2:	20 81       	ld	r18, Z
 de4:	31 81       	ldd	r19, Z+1	; 0x01
 de6:	28 0f       	add	r18, r24
 de8:	39 1f       	adc	r19, r25
 dea:	80 91 89 02 	lds	r24, 0x0289
 dee:	90 91 8a 02 	lds	r25, 0x028A
 df2:	82 17       	cp	r24, r18
 df4:	93 07       	cpc	r25, r19
 df6:	79 f5       	brne	.+94     	; 0xe56 <free+0x92>
 df8:	f0 93 8a 02 	sts	0x028A, r31
 dfc:	e0 93 89 02 	sts	0x0289, r30
 e00:	6d c0       	rjmp	.+218    	; 0xedc <free+0x118>
 e02:	de 01       	movw	r26, r28
 e04:	20 e0       	ldi	r18, 0x00	; 0
 e06:	30 e0       	ldi	r19, 0x00	; 0
 e08:	ae 17       	cp	r26, r30
 e0a:	bf 07       	cpc	r27, r31
 e0c:	50 f4       	brcc	.+20     	; 0xe22 <free+0x5e>
 e0e:	12 96       	adiw	r26, 0x02	; 2
 e10:	4d 91       	ld	r20, X+
 e12:	5c 91       	ld	r21, X
 e14:	13 97       	sbiw	r26, 0x03	; 3
 e16:	9d 01       	movw	r18, r26
 e18:	41 15       	cp	r20, r1
 e1a:	51 05       	cpc	r21, r1
 e1c:	09 f1       	breq	.+66     	; 0xe60 <free+0x9c>
 e1e:	da 01       	movw	r26, r20
 e20:	f3 cf       	rjmp	.-26     	; 0xe08 <free+0x44>
 e22:	b3 83       	std	Z+3, r27	; 0x03
 e24:	a2 83       	std	Z+2, r26	; 0x02
 e26:	40 81       	ld	r20, Z
 e28:	51 81       	ldd	r21, Z+1	; 0x01
 e2a:	84 0f       	add	r24, r20
 e2c:	95 1f       	adc	r25, r21
 e2e:	8a 17       	cp	r24, r26
 e30:	9b 07       	cpc	r25, r27
 e32:	71 f4       	brne	.+28     	; 0xe50 <free+0x8c>
 e34:	8d 91       	ld	r24, X+
 e36:	9c 91       	ld	r25, X
 e38:	11 97       	sbiw	r26, 0x01	; 1
 e3a:	84 0f       	add	r24, r20
 e3c:	95 1f       	adc	r25, r21
 e3e:	02 96       	adiw	r24, 0x02	; 2
 e40:	91 83       	std	Z+1, r25	; 0x01
 e42:	80 83       	st	Z, r24
 e44:	12 96       	adiw	r26, 0x02	; 2
 e46:	8d 91       	ld	r24, X+
 e48:	9c 91       	ld	r25, X
 e4a:	13 97       	sbiw	r26, 0x03	; 3
 e4c:	93 83       	std	Z+3, r25	; 0x03
 e4e:	82 83       	std	Z+2, r24	; 0x02
 e50:	21 15       	cp	r18, r1
 e52:	31 05       	cpc	r19, r1
 e54:	29 f4       	brne	.+10     	; 0xe60 <free+0x9c>
 e56:	f0 93 8c 02 	sts	0x028C, r31
 e5a:	e0 93 8b 02 	sts	0x028B, r30
 e5e:	3e c0       	rjmp	.+124    	; 0xedc <free+0x118>
 e60:	d9 01       	movw	r26, r18
 e62:	13 96       	adiw	r26, 0x03	; 3
 e64:	fc 93       	st	X, r31
 e66:	ee 93       	st	-X, r30
 e68:	12 97       	sbiw	r26, 0x02	; 2
 e6a:	4d 91       	ld	r20, X+
 e6c:	5d 91       	ld	r21, X+
 e6e:	a4 0f       	add	r26, r20
 e70:	b5 1f       	adc	r27, r21
 e72:	ea 17       	cp	r30, r26
 e74:	fb 07       	cpc	r31, r27
 e76:	79 f4       	brne	.+30     	; 0xe96 <free+0xd2>
 e78:	80 81       	ld	r24, Z
 e7a:	91 81       	ldd	r25, Z+1	; 0x01
 e7c:	84 0f       	add	r24, r20
 e7e:	95 1f       	adc	r25, r21
 e80:	02 96       	adiw	r24, 0x02	; 2
 e82:	d9 01       	movw	r26, r18
 e84:	11 96       	adiw	r26, 0x01	; 1
 e86:	9c 93       	st	X, r25
 e88:	8e 93       	st	-X, r24
 e8a:	82 81       	ldd	r24, Z+2	; 0x02
 e8c:	93 81       	ldd	r25, Z+3	; 0x03
 e8e:	13 96       	adiw	r26, 0x03	; 3
 e90:	9c 93       	st	X, r25
 e92:	8e 93       	st	-X, r24
 e94:	12 97       	sbiw	r26, 0x02	; 2
 e96:	e0 e0       	ldi	r30, 0x00	; 0
 e98:	f0 e0       	ldi	r31, 0x00	; 0
 e9a:	8a 81       	ldd	r24, Y+2	; 0x02
 e9c:	9b 81       	ldd	r25, Y+3	; 0x03
 e9e:	00 97       	sbiw	r24, 0x00	; 0
 ea0:	19 f0       	breq	.+6      	; 0xea8 <free+0xe4>
 ea2:	fe 01       	movw	r30, r28
 ea4:	ec 01       	movw	r28, r24
 ea6:	f9 cf       	rjmp	.-14     	; 0xe9a <free+0xd6>
 ea8:	ce 01       	movw	r24, r28
 eaa:	02 96       	adiw	r24, 0x02	; 2
 eac:	28 81       	ld	r18, Y
 eae:	39 81       	ldd	r19, Y+1	; 0x01
 eb0:	82 0f       	add	r24, r18
 eb2:	93 1f       	adc	r25, r19
 eb4:	20 91 89 02 	lds	r18, 0x0289
 eb8:	30 91 8a 02 	lds	r19, 0x028A
 ebc:	28 17       	cp	r18, r24
 ebe:	39 07       	cpc	r19, r25
 ec0:	69 f4       	brne	.+26     	; 0xedc <free+0x118>
 ec2:	30 97       	sbiw	r30, 0x00	; 0
 ec4:	29 f4       	brne	.+10     	; 0xed0 <free+0x10c>
 ec6:	10 92 8c 02 	sts	0x028C, r1
 eca:	10 92 8b 02 	sts	0x028B, r1
 ece:	02 c0       	rjmp	.+4      	; 0xed4 <free+0x110>
 ed0:	13 82       	std	Z+3, r1	; 0x03
 ed2:	12 82       	std	Z+2, r1	; 0x02
 ed4:	d0 93 8a 02 	sts	0x028A, r29
 ed8:	c0 93 89 02 	sts	0x0289, r28
 edc:	df 91       	pop	r29
 ede:	cf 91       	pop	r28
 ee0:	08 95       	ret

00000ee2 <fdevopen>:
 ee2:	0f 93       	push	r16
 ee4:	1f 93       	push	r17
 ee6:	cf 93       	push	r28
 ee8:	df 93       	push	r29
 eea:	ec 01       	movw	r28, r24
 eec:	8b 01       	movw	r16, r22
 eee:	00 97       	sbiw	r24, 0x00	; 0
 ef0:	31 f4       	brne	.+12     	; 0xefe <fdevopen+0x1c>
 ef2:	61 15       	cp	r22, r1
 ef4:	71 05       	cpc	r23, r1
 ef6:	19 f4       	brne	.+6      	; 0xefe <fdevopen+0x1c>
 ef8:	80 e0       	ldi	r24, 0x00	; 0
 efa:	90 e0       	ldi	r25, 0x00	; 0
 efc:	38 c0       	rjmp	.+112    	; 0xf6e <fdevopen+0x8c>
 efe:	6e e0       	ldi	r22, 0x0E	; 14
 f00:	70 e0       	ldi	r23, 0x00	; 0
 f02:	81 e0       	ldi	r24, 0x01	; 1
 f04:	90 e0       	ldi	r25, 0x00	; 0
 f06:	0e 94 bc 07 	call	0xf78	; 0xf78 <calloc>
 f0a:	fc 01       	movw	r30, r24
 f0c:	00 97       	sbiw	r24, 0x00	; 0
 f0e:	a1 f3       	breq	.-24     	; 0xef8 <fdevopen+0x16>
 f10:	80 e8       	ldi	r24, 0x80	; 128
 f12:	83 83       	std	Z+3, r24	; 0x03
 f14:	01 15       	cp	r16, r1
 f16:	11 05       	cpc	r17, r1
 f18:	71 f0       	breq	.+28     	; 0xf36 <fdevopen+0x54>
 f1a:	13 87       	std	Z+11, r17	; 0x0b
 f1c:	02 87       	std	Z+10, r16	; 0x0a
 f1e:	81 e8       	ldi	r24, 0x81	; 129
 f20:	83 83       	std	Z+3, r24	; 0x03
 f22:	80 91 8d 02 	lds	r24, 0x028D
 f26:	90 91 8e 02 	lds	r25, 0x028E
 f2a:	89 2b       	or	r24, r25
 f2c:	21 f4       	brne	.+8      	; 0xf36 <fdevopen+0x54>
 f2e:	f0 93 8e 02 	sts	0x028E, r31
 f32:	e0 93 8d 02 	sts	0x028D, r30
 f36:	20 97       	sbiw	r28, 0x00	; 0
 f38:	c9 f0       	breq	.+50     	; 0xf6c <fdevopen+0x8a>
 f3a:	d1 87       	std	Z+9, r29	; 0x09
 f3c:	c0 87       	std	Z+8, r28	; 0x08
 f3e:	83 81       	ldd	r24, Z+3	; 0x03
 f40:	82 60       	ori	r24, 0x02	; 2
 f42:	83 83       	std	Z+3, r24	; 0x03
 f44:	80 91 8f 02 	lds	r24, 0x028F
 f48:	90 91 90 02 	lds	r25, 0x0290
 f4c:	89 2b       	or	r24, r25
 f4e:	71 f4       	brne	.+28     	; 0xf6c <fdevopen+0x8a>
 f50:	f0 93 90 02 	sts	0x0290, r31
 f54:	e0 93 8f 02 	sts	0x028F, r30
 f58:	80 91 91 02 	lds	r24, 0x0291
 f5c:	90 91 92 02 	lds	r25, 0x0292
 f60:	89 2b       	or	r24, r25
 f62:	21 f4       	brne	.+8      	; 0xf6c <fdevopen+0x8a>
 f64:	f0 93 92 02 	sts	0x0292, r31
 f68:	e0 93 91 02 	sts	0x0291, r30
 f6c:	cf 01       	movw	r24, r30
 f6e:	df 91       	pop	r29
 f70:	cf 91       	pop	r28
 f72:	1f 91       	pop	r17
 f74:	0f 91       	pop	r16
 f76:	08 95       	ret

00000f78 <calloc>:
 f78:	0f 93       	push	r16
 f7a:	1f 93       	push	r17
 f7c:	cf 93       	push	r28
 f7e:	df 93       	push	r29
 f80:	86 9f       	mul	r24, r22
 f82:	80 01       	movw	r16, r0
 f84:	87 9f       	mul	r24, r23
 f86:	10 0d       	add	r17, r0
 f88:	96 9f       	mul	r25, r22
 f8a:	10 0d       	add	r17, r0
 f8c:	11 24       	eor	r1, r1
 f8e:	c8 01       	movw	r24, r16
 f90:	0e 94 4a 06 	call	0xc94	; 0xc94 <malloc>
 f94:	ec 01       	movw	r28, r24
 f96:	00 97       	sbiw	r24, 0x00	; 0
 f98:	29 f0       	breq	.+10     	; 0xfa4 <calloc+0x2c>
 f9a:	a8 01       	movw	r20, r16
 f9c:	60 e0       	ldi	r22, 0x00	; 0
 f9e:	70 e0       	ldi	r23, 0x00	; 0
 fa0:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <memset>
 fa4:	ce 01       	movw	r24, r28
 fa6:	df 91       	pop	r29
 fa8:	cf 91       	pop	r28
 faa:	1f 91       	pop	r17
 fac:	0f 91       	pop	r16
 fae:	08 95       	ret

00000fb0 <memset>:
 fb0:	dc 01       	movw	r26, r24
 fb2:	01 c0       	rjmp	.+2      	; 0xfb6 <memset+0x6>
 fb4:	6d 93       	st	X+, r22
 fb6:	41 50       	subi	r20, 0x01	; 1
 fb8:	50 40       	sbci	r21, 0x00	; 0
 fba:	e0 f7       	brcc	.-8      	; 0xfb4 <memset+0x4>
 fbc:	08 95       	ret

00000fbe <_exit>:
 fbe:	f8 94       	cli

00000fc0 <__stop_program>:
 fc0:	ff cf       	rjmp	.-2      	; 0xfc0 <__stop_program>
